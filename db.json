{"meta":{"version":1,"warehouse":"4.0.0"},"models":{"Asset":[{"_id":"themes/hexo-theme-yuzu/source/css/about.styl","path":"css/about.styl","modified":0,"renderable":1},{"_id":"themes/hexo-theme-yuzu/source/css/biblio.styl","path":"css/biblio.styl","modified":0,"renderable":1},{"_id":"themes/hexo-theme-yuzu/source/css/category.styl","path":"css/category.styl","modified":0,"renderable":1},{"_id":"themes/hexo-theme-yuzu/source/css/font.styl","path":"css/font.styl","modified":0,"renderable":1},{"_id":"themes/hexo-theme-yuzu/source/css/index.styl","path":"css/index.styl","modified":0,"renderable":1},{"_id":"themes/hexo-theme-yuzu/source/css/layout.styl","path":"css/layout.styl","modified":0,"renderable":1},{"_id":"themes/hexo-theme-yuzu/source/css/loading.styl","path":"css/loading.styl","modified":0,"renderable":1},{"_id":"themes/hexo-theme-yuzu/source/css/style.styl","path":"css/style.styl","modified":0,"renderable":1},{"_id":"themes/hexo-theme-yuzu/source/css/tags.styl","path":"css/tags.styl","modified":0,"renderable":1},{"_id":"themes/hexo-theme-yuzu/source/fonts/icons.eot","path":"fonts/icons.eot","modified":0,"renderable":1},{"_id":"themes/hexo-theme-yuzu/source/fonts/icons.svg","path":"fonts/icons.svg","modified":0,"renderable":1},{"_id":"themes/hexo-theme-yuzu/source/fonts/icons.ttf","path":"fonts/icons.ttf","modified":0,"renderable":1},{"_id":"themes/hexo-theme-yuzu/source/fonts/icons.woff","path":"fonts/icons.woff","modified":0,"renderable":1},{"_id":"themes/hexo-theme-yuzu/source/img/favicon.ico","path":"img/favicon.ico","modified":0,"renderable":1},{"_id":"themes/hexo-theme-yuzu/source/img/icp.png","path":"img/icp.png","modified":0,"renderable":1},{"_id":"themes/hexo-theme-yuzu/source/js/index.js","path":"js/index.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-yuzu/source/js/theme.js","path":"js/theme.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-yuzu/source/js/clipboard/clipboard.min.js","path":"js/clipboard/clipboard.min.js","modified":0,"renderable":1}],"Cache":[{"_id":"source/_posts/UGUI源码解析-1.md","hash":"de47791978edabd976e0219bdf629124079b44e1","modified":1647357120564},{"_id":"source/_posts/hello-world.md","hash":"466287759116937c988ae640f69cd5e6e3232071","modified":1647355580582},{"_id":"source/_posts/test.md","hash":"1b859357763799917efc7b66a2e499e579346cb9","modified":1647355541689},{"_id":"source/categories/index.md","hash":"5d1fe31bd7876242dc6b07cc8fc5c64543d9ff3e","modified":1647356512326},{"_id":"themes/hexo-theme-yuzu/.gitignore","hash":"e0ed028c2b034754ba17b141041c4b6fb2499177","modified":1647346751890},{"_id":"themes/hexo-theme-yuzu/LICENSE","hash":"f16a2c9f59829b616f020ee0d39e92e4a3567deb","modified":1647346751891},{"_id":"themes/hexo-theme-yuzu/_config.yml","hash":"720eaa261dbfac1033f295018845ee5a45c1776a","modified":1647356054533},{"_id":"themes/hexo-theme-yuzu/mknextver","hash":"9023c77f950fd9120562831edc14f8613e26c67c","modified":1647346751909},{"_id":"themes/hexo-theme-yuzu/readme.md","hash":"8d62e1d03c9ea1ad03f6ffb54e353c390594d328","modified":1647346751909},{"_id":"themes/hexo-theme-yuzu/languages/en.yml","hash":"63f93f0e0d6cc0038bc4a6cdc8e61cc960bcad01","modified":1647346751892},{"_id":"themes/hexo-theme-yuzu/languages/zh.yml","hash":"ac37c402f84f5cfb0e8adef6f93adcfc5b1276f8","modified":1647346751893},{"_id":"themes/hexo-theme-yuzu/layout/404.ejs","hash":"e957ee50795085c6f52e83bb5eaf9c2e7c22ea10","modified":1647346751894},{"_id":"themes/hexo-theme-yuzu/layout/about.ejs","hash":"21ba91395722d0d6066aec017d1e01b6e93bb6d4","modified":1647346751906},{"_id":"themes/hexo-theme-yuzu/layout/archive.ejs","hash":"66d6246f229474214eee861ba70c873c94d08308","modified":1647346751906},{"_id":"themes/hexo-theme-yuzu/layout/category.ejs","hash":"3f3267abb345981a030092e20fcef86bd9fbe435","modified":1647346751907},{"_id":"themes/hexo-theme-yuzu/layout/index.ejs","hash":"719a396c8b90caf7cee95a3183ba9a00672a3aa6","modified":1647346751907},{"_id":"themes/hexo-theme-yuzu/layout/layout.ejs","hash":"a54bed3a2e70394bf44e8d384c28d862673a57a9","modified":1647346751907},{"_id":"themes/hexo-theme-yuzu/layout/page.ejs","hash":"7d80e4e36b14d30a7cd2ac1f61376d9ebf264e8b","modified":1647346751907},{"_id":"themes/hexo-theme-yuzu/layout/post.ejs","hash":"25198a66f8e03031601aba3111a13721dfbda7d3","modified":1647346751908},{"_id":"themes/hexo-theme-yuzu/layout/tags.ejs","hash":"0732737f988e3a76e8472e3a6ce8bad91ef08e98","modified":1647346751908},{"_id":"themes/hexo-theme-yuzu/layout/_partial/after-footer.ejs","hash":"c2ccae0e31d5df9294095a2a39c7b0eb1fd075a3","modified":1647346751895},{"_id":"themes/hexo-theme-yuzu/layout/_partial/archive-post.ejs","hash":"e11b1094f0882c6f1f28375260eda47d1293e996","modified":1647346751895},{"_id":"themes/hexo-theme-yuzu/layout/_partial/archive.ejs","hash":"7470b870911c7e5536d07a2501b9489fb5079440","modified":1647346751896},{"_id":"themes/hexo-theme-yuzu/layout/_partial/article-list-item.ejs","hash":"dc6d6277fa1ca873bb6a5a2416ef8e0f26d2e34d","modified":1647346751896},{"_id":"themes/hexo-theme-yuzu/layout/_partial/article.ejs","hash":"a05365831377192166a7dc7f800bc3a2c970fb9c","modified":1647346751897},{"_id":"themes/hexo-theme-yuzu/layout/_partial/footer.ejs","hash":"174087e992ca40d5a8340b39cea0d856781f1d86","modified":1647346751897},{"_id":"themes/hexo-theme-yuzu/layout/_partial/head-bar.ejs","hash":"5d09c5684334221d50cca43aec31c46aef014c9a","modified":1647346751898},{"_id":"themes/hexo-theme-yuzu/layout/_partial/head.ejs","hash":"b38899ca76e34eb154ff57c5d2fea4d86aef88fc","modified":1647346751898},{"_id":"themes/hexo-theme-yuzu/layout/_partial/header.ejs","hash":"a2542235ef6e126ff3271ba46b64b39bbc8e2ea3","modified":1647346751899},{"_id":"themes/hexo-theme-yuzu/layout/_partial/menu.ejs","hash":"b06dd887db66fe9352e49d2030cc084f85b764e6","modified":1647346751899},{"_id":"themes/hexo-theme-yuzu/layout/_partial/pagination.ejs","hash":"62c5de766cfb5b5e0d97611ec6b4100a0d4f7397","modified":1647346751900},{"_id":"themes/hexo-theme-yuzu/layout/_partial/tags.ejs","hash":"5058bc201463aaf9b38d5a72f31dc152d830eea2","modified":1647346751904},{"_id":"themes/hexo-theme-yuzu/layout/_widget/Archives.ejs","hash":"d3aa054738c913a240008e563863a3084e7fd14d","modified":1647346751905},{"_id":"themes/hexo-theme-yuzu/layout/_widget/Posts.ejs","hash":"745b81447d62603f20a7175921e2c0b6fdddd736","modified":1647346751905},{"_id":"themes/hexo-theme-yuzu/layout/_widget/Tags.ejs","hash":"53c61482a3c6da9665932169038732bf154cb591","modified":1647346751906},{"_id":"themes/hexo-theme-yuzu/source/css/_variables.styl","hash":"0d0b2c1582db5f599cd13cb6e9212e6792be1815","modified":1647346751918},{"_id":"themes/hexo-theme-yuzu/source/css/about.styl","hash":"d3d5d4571f0f599558b7eb79ff66f340c160f8be","modified":1647346751919},{"_id":"themes/hexo-theme-yuzu/source/css/biblio.styl","hash":"7797fd53665571b52c1a89719338910ccc4711a2","modified":1647346751919},{"_id":"themes/hexo-theme-yuzu/source/css/category.styl","hash":"e04a3438a3eff70d19ffdda6219ea8a1afdfbadc","modified":1647346751919},{"_id":"themes/hexo-theme-yuzu/source/css/font.styl","hash":"a0f7236a57887a64665fed42b8aa45e8afbd2222","modified":1647346751920},{"_id":"themes/hexo-theme-yuzu/source/css/index.styl","hash":"8bcd856d39cbd216fcdf1c30e12314b6ccb18208","modified":1647346751920},{"_id":"themes/hexo-theme-yuzu/source/css/layout.styl","hash":"d5fcc259a8e0be74a0a306be1709c645b18c7ffb","modified":1647346751921},{"_id":"themes/hexo-theme-yuzu/source/css/loading.styl","hash":"c90d4f76982e08fcbefe996db0492b441a609419","modified":1647346751921},{"_id":"themes/hexo-theme-yuzu/source/css/style.styl","hash":"d3153ef99fb0f89ffc1828a99e15f2fe77bd4cde","modified":1647346751921},{"_id":"themes/hexo-theme-yuzu/source/css/tags.styl","hash":"bab86ea632f80f97c0bfe54f935795165884cd6e","modified":1647346751922},{"_id":"themes/hexo-theme-yuzu/source/fonts/icons.eot","hash":"54a7bddf83ec7284aebb0ad95ffe1ed59f8c256e","modified":1647346751922},{"_id":"themes/hexo-theme-yuzu/source/fonts/icons.svg","hash":"0424cf4272a673d4fd08747a1de914a6208a29fc","modified":1647346751922},{"_id":"themes/hexo-theme-yuzu/source/fonts/icons.woff","hash":"ecedd08f41a649877d47337c9b27a28f5b95ae26","modified":1647346751923},{"_id":"themes/hexo-theme-yuzu/source/fonts/icons.ttf","hash":"439e7966de0842901932d8c72118dcd5439d0193","modified":1647346751923},{"_id":"themes/hexo-theme-yuzu/source/img/favicon.ico","hash":"bed500dd45b661413a0dab3fa6bbb226994feafe","modified":1647395208601},{"_id":"themes/hexo-theme-yuzu/source/img/icp.png","hash":"7ec67ebc6cf0b3c79ec5cdd35b8c48f2fef2d80e","modified":1647346751924},{"_id":"themes/hexo-theme-yuzu/source/js/index.js","hash":"3becdc1b580e99957a9a7fc09fc88b468ffadf3c","modified":1647346751935},{"_id":"themes/hexo-theme-yuzu/source/js/theme.js","hash":"422ee36900878094a8cff20297eebc786aad9267","modified":1647346751935},{"_id":"themes/hexo-theme-yuzu/layout/_partial/post/archive-title.ejs","hash":"8ce27479b818e71fabc91ac3b0d92baca5c958a1","modified":1647346751900},{"_id":"themes/hexo-theme-yuzu/layout/_partial/post/category.ejs","hash":"16128d2422645e18d1b6882d4c4df17d895bd76e","modified":1647346751901},{"_id":"themes/hexo-theme-yuzu/layout/_partial/post/date.ejs","hash":"e817b6cbe053054e4ddafede76092fd45c30cda9","modified":1647346751901},{"_id":"themes/hexo-theme-yuzu/layout/_partial/post/gallery.ejs","hash":"b0bf3f5d923c261ca2b5fabab513f1ec2708c8ca","modified":1647346751901},{"_id":"themes/hexo-theme-yuzu/layout/_partial/post/nav.ejs","hash":"cbb3819ce512bd24db8bad41b8617d46eba82fdc","modified":1647346751902},{"_id":"themes/hexo-theme-yuzu/layout/_partial/post/tag.ejs","hash":"694b5101bcc44c9f9c1cc62e5ad2fdfb4b7c7a07","modified":1647346751902},{"_id":"themes/hexo-theme-yuzu/layout/_partial/post/toc.ejs","hash":"999baeb29a7766b1ab29da837b38ae11b3101fa1","modified":1647346751904},{"_id":"themes/hexo-theme-yuzu/layout/_partial/post/word-count.ejs","hash":"e08ba7f22b56678f676ba35bb5c5ca3cb28e1e9f","modified":1647346751904},{"_id":"themes/hexo-theme-yuzu/source/css/_defaults/color.styl","hash":"5cd986a672b6e0f65735fc80a8465747ed8aaeba","modified":1647346751910},{"_id":"themes/hexo-theme-yuzu/source/css/_defaults/icon.styl","hash":"0742166a9439b3f8c4d71a74362654ec79672f9c","modified":1647346751910},{"_id":"themes/hexo-theme-yuzu/source/css/_defaults/nav.styl","hash":"d744599a3ffad1e4fb0acf98c3adb3381c3cf4bb","modified":1647346751911},{"_id":"themes/hexo-theme-yuzu/source/css/_defaults/pagination.styl","hash":"6afc08be2297ae2485a27c77a3186afcffb66d45","modified":1647346751911},{"_id":"themes/hexo-theme-yuzu/source/css/_defaults/round-corner.styl","hash":"60a0ad85541abfa51f3b975e5c5883d1dcb708f2","modified":1647346751911},{"_id":"themes/hexo-theme-yuzu/source/css/_defaults/text.styl","hash":"03472dde293724c3c64c37635128e2e82db6423d","modified":1647346751912},{"_id":"themes/hexo-theme-yuzu/source/css/_defaults/title.styl","hash":"99b4a70a88bd5b259a3b79621fc15a8f6562d5f6","modified":1647346751913},{"_id":"themes/hexo-theme-yuzu/source/css/_partial/archive.styl","hash":"c254b39aae4ecc373657024bed783bd08621f31d","modified":1647346751913},{"_id":"themes/hexo-theme-yuzu/source/css/_partial/article-list-item.styl","hash":"ec759f9152163e14a42fc10fbeed2fe41461eede","modified":1647346751914},{"_id":"themes/hexo-theme-yuzu/source/css/_partial/article.styl","hash":"6c9380e28805cda36d4b58c62508bc6bd64efaed","modified":1647346751914},{"_id":"themes/hexo-theme-yuzu/source/css/_partial/footer.styl","hash":"38a7b8abbe3558d814a3515eeb4355b5dfa6944b","modified":1647346751915},{"_id":"themes/hexo-theme-yuzu/source/css/_partial/head-bar.styl","hash":"da8c1e51dbbed5fe69a803270f140a6644e4f40d","modified":1647346751915},{"_id":"themes/hexo-theme-yuzu/source/css/_partial/header.styl","hash":"2f4abd2d8e130d4f67fd79f0d88282fe29a5ed1a","modified":1647346751915},{"_id":"themes/hexo-theme-yuzu/source/css/_partial/highlight.styl","hash":"9be5cd1f7d369b459be3cfbe07957594c11f3145","modified":1647346751917},{"_id":"themes/hexo-theme-yuzu/source/css/_partial/menu.styl","hash":"fae9a28583403878e32e2dad87299d510f9bf9d6","modified":1647346751917},{"_id":"themes/hexo-theme-yuzu/source/js/clipboard/clipboard.min.js","hash":"a5146e0761c3d4169153e9960c9a0b4173153bd4","modified":1647346751934},{"_id":"themes/hexo-theme-yuzu/source/css/_partial/highlight-themes/atom-one-dark.styl","hash":"f61a04da67afe56598a2cbdc17e0dd8457764ea3","modified":1647346751916},{"_id":"themes/hexo-theme-yuzu/source/css/_partial/highlight-themes/atom-one-light.styl","hash":"7be96cd3916f0531d54a00842936c8c4c5718a79","modified":1647346751916},{"_id":"themes/hexo-theme-yuzu/source/css/_partial/post/toc.styl","hash":"624b18835aa68a0d7c414641f87676e22ff8942d","modified":1647346751918},{"_id":"public/categories/index.html","hash":"11ee20521670df6e1a48e28f967bb766e8782c6b","modified":1647358566297},{"_id":"public/2022/03/15/test/index.html","hash":"3aa4c2f4a7f5ed887e7a64b9e92bc8d35ab0b255","modified":1647358566297},{"_id":"public/2022/03/15/hello-world/index.html","hash":"b5df8d51d5b321fa180642083ecf5b1c7d1e5926","modified":1647358566297},{"_id":"public/archives/index.html","hash":"40f8adc9d332277c7ac061247944b3e00af1c17a","modified":1647358566297},{"_id":"public/archives/2022/index.html","hash":"40f8adc9d332277c7ac061247944b3e00af1c17a","modified":1647358566297},{"_id":"public/archives/2022/03/index.html","hash":"40f8adc9d332277c7ac061247944b3e00af1c17a","modified":1647358566297},{"_id":"public/categories/program/index.html","hash":"3553c68a2124a17f26f14b2363cf40ebc5b4d031","modified":1647358566297},{"_id":"public/categories/article/index.html","hash":"1816ea10102577e84cd1b7d82f194d9d74c3a180","modified":1647358566297},{"_id":"public/index.html","hash":"4d70a412f172aa8f6ca4758ed04e6ce3d2d66228","modified":1647358566297},{"_id":"public/tags/program/index.html","hash":"90a9b03217280b096b4f66a36966212cddfde1dc","modified":1647358566297},{"_id":"public/tags/article/index.html","hash":"818fec3dae5d9019b5741d33233b63bbfb532f78","modified":1647358566297},{"_id":"public/2022/03/15/UGUI源码解析-1/index.html","hash":"fb43d016b7ab1a0a1d487a88b8eea702883ab158","modified":1647358566297},{"_id":"public/fonts/icons.eot","hash":"54a7bddf83ec7284aebb0ad95ffe1ed59f8c256e","modified":1647358447205},{"_id":"public/fonts/icons.svg","hash":"0424cf4272a673d4fd08747a1de914a6208a29fc","modified":1647358447205},{"_id":"public/fonts/icons.ttf","hash":"439e7966de0842901932d8c72118dcd5439d0193","modified":1647358447205},{"_id":"public/fonts/icons.woff","hash":"ecedd08f41a649877d47337c9b27a28f5b95ae26","modified":1647358447205},{"_id":"public/img/favicon.ico","hash":"d6a57f4a2c685890bf33a4f8f7205895ca3647c6","modified":1647358447205},{"_id":"public/img/icp.png","hash":"7ec67ebc6cf0b3c79ec5cdd35b8c48f2fef2d80e","modified":1647358447205},{"_id":"public/css/about.css","hash":"a7db726b85b9a84ac7c7de0a2b832087d3ee673f","modified":1647358447205},{"_id":"public/css/biblio.css","hash":"2e67b6744bc7673446aab89aa79acdf756c0c8c2","modified":1647358447205},{"_id":"public/css/category.css","hash":"3771cde68e2e8ec9872c634b5c0fce23bd15407a","modified":1647358447205},{"_id":"public/css/font.css","hash":"26549e0a31d6fcabe51374c4c9cef21ab9ccd801","modified":1647358447205},{"_id":"public/css/index.css","hash":"d0c6ea73e0c7a1bfac86426bbc7b47ced1f82bc5","modified":1647358447205},{"_id":"public/css/layout.css","hash":"e35c75b68118663bfb9d13e5c5e876cfeb7012d2","modified":1647358447205},{"_id":"public/css/loading.css","hash":"0d5af59d856624694fb1ab4985c91d0f67ee414f","modified":1647358447205},{"_id":"public/css/tags.css","hash":"8425438e741c47d395285e3428c3f5987aba0365","modified":1647358447205},{"_id":"public/js/index.js","hash":"df1a9d4202d5b5eb1643c365972f795e75fe7e13","modified":1647358447205},{"_id":"public/js/theme.js","hash":"312ea897367015234999b4be8add7d666cd616c9","modified":1647358447205},{"_id":"public/js/clipboard/clipboard.min.js","hash":"35cff8543a2d61e22eaa1c565b3457675c04571a","modified":1647358447205},{"_id":"public/css/style.css","hash":"384460ea5331f019a21da8ac0d02e431b5b900a2","modified":1647358447205},{"_id":"source/fix/index.md","hash":"0b0f98c68ffc9313726f0a90fc0517023e4f0134","modified":1647358459649},{"_id":"public/fix/index.html","hash":"d2db8573b7e75ed7a7f9b59560dd14d6d562eb4a","modified":1647358566297}],"Category":[{"name":"program","_id":"cl0saopl10005d0vh7fjcftih"},{"name":"article","_id":"cl0saopl90007d0vh6l5a9xzi"}],"Data":[],"Page":[{"title":"categories","date":"2022-03-15T14:13:33.000Z","type":[["program"],["article"]],"_content":"","source":"categories/index.md","raw":"---\ntitle: categories\ndate: 2022-03-15 22:13:33\ntype: \n  - [program]\n  - [article]\n---\n","updated":"2022-03-15T15:01:52.326Z","path":"categories/index.html","comments":1,"layout":"page","_id":"cl0saopk60000d0vh4adh8t1o","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"fix","date":"2022-03-15T15:34:19.000Z","_content":"","source":"fix/index.md","raw":"---\ntitle: fix\ndate: 2022-03-15 23:34:19\n---\n","updated":"2022-03-15T15:34:19.649Z","path":"fix/index.html","comments":1,"layout":"page","_id":"cl0sap4k10000rovh4j55cud5","content":"","site":{"data":{}},"excerpt":"","more":""}],"Post":[{"title":"UGUI源码解析(1)","date":"2022-03-15T15:04:38.000Z","_content":"\n## **01 | 从`Button`开始解读`UGUI`源码**\n\n在Unity中，Button是我们最常用的组件之一了，它使用起来非常简单，例如监听一个Button点击事件\n\n```csharp\nGetComponent<Button>().onClick.AddListener(() => { \n    ...//按钮点击的处理逻辑\n});\n```\n\n这样使用没有任何问题，但有时候我们会有疑问，为什么点击按钮`onClick`事件就会被触发呢？如何从回调函数中获取按钮的参数？让我们从源码中寻找答案。\n\n## **查看源码前的配置**\n\n为了能够方便的查阅源码以及进行代码调试，需要重新导入`UGUI`包。新建Unity项目，找到`Project/Packages/Unity UI`，右键 `Show in Explorer`，将其复制到任意一个新的文件夹中(记住保存的位置，待会需要引用)。\n\n接下来打开`Window/Package Manager`\n\n![](https://pic1.zhimg.com/80/v2-3ccfbcede96e7528a3b02780975fa198_720w.jpg)\n\n找到`Unity UI`，将其`Remove`\n\n![](https://pic1.zhimg.com/80/v2-2f23bd59190b84d78c1249ac0ebde634_720w.jpg)\n\n然后点击`“+”`号，选择`Add package form disk...`，找到之前保存的UI包，进入目录后选中`package.json`，点击打开。\n\n![](https://pic1.zhimg.com/80/v2-63a9b186c1eaf811361227c1e2d752e0_720w.jpg)\n\n大功告成，现在我们可以查看/修改`UGUI`的源码了。\n\n## **探究`UGUI`源码**\n\n### **`Button`的调用链**\n\n通过`F12`打开`Button`代码，容易发现它继承`Selectable`类，同时还继承了`IPointerClickHandler`、`ISubmitHandler`接口，这两个接口分别会在鼠标点击、点击提交按钮时调用它们的回调函数。\n\n```text\n public class Button : Selectable, IPointerClickHandler, ISubmitHandler\n {\n     [Serializable]\n     //定义一个点击事件\n     public class ButtonClickedEvent : UnityEvent {}\n\n     // 实例化一个ButtonClickedEvent的事件\n     [FormerlySerializedAs(\"onClick\")]\n     [SerializeField]\n     private ButtonClickedEvent m_OnClick = new ButtonClickedEvent();\n\n     protected Button()\n     {}\n  \n     //常用的onClick.AddListener()就是监听这个事件\n     public ButtonClickedEvent onClick\n     {\n         get { return m_OnClick; }\n         set { m_OnClick = value; }\n     }\n   \n     //如果按钮处于活跃状态并且可交互(Interactable设置为true)，则触发事件\n     private void Press()\n     {\n         if (!IsActive() || !IsInteractable())\n             return;\n\n         UISystemProfilerApi.AddMarker(\"Button.onClick\", this);\n         m_OnClick.Invoke();\n     }\n  \n     //鼠标点击时调用该函数，继承自 IPointerClickHandler 接口\n     public virtual void OnPointerClick(PointerEventData eventData)\n     {\n         if (eventData.button != PointerEventData.InputButton.Left)\n             return;\n\n         Press();\n     }\n  \n     //按下“提交”键后触发(需要先选中该游戏物体)，继承自 ISubmitHandler\n     //\"提交\"键可以在 Edit->Project Settings->Input->Submit 中自定义\n     public virtual void OnSubmit(BaseEventData eventData){...}\n\n     private IEnumerator OnFinishSubmit(){...}\n}\n```\n\n`IPointerClickHandler`接口仅包含一个`OnPointerClick()`方法，当鼠标点击时会调用该接口的方法。而`Button`能触发点击事件是因为继承自`IPointerClickHandler`接口，并且重写了`OnPointerClick`方法。\n\n那`IPointerClickHandler`接口的方法又是被谁调用的呢？查找引用，发现是`ExecuteEvents`类的`Execute`方法(该类相当于事件执行器，提供了许多通用的事件处理方法)，并且`Execute`方法赋值给`s_PointerClickHandler`字段。\n\n```csharp\nprivate static readonly EventFunction<IPointerClickHandler> s_PointerClickHandler = Execute;\nprivate static void Execute(IPointerClickHandler handler, BaseEventData eventData)\n{\n    handler.OnPointerClick(ValidateEventData<PointerEventData>(eventData));\n}\n```\n\n **为了能看的更清楚，总结一下调用关系，即`Button`继承自`Selectable`、`IPointercliClickHandler`、`ISubmitHandler`，而`IPointercliClickHandler`、`ISubmitHandler`继承自`IEventSystemHandler`，`ExecuteEvent`会在鼠标松开时通过`Execute`函数调用`IPointercliClickHandler`、`ISubmitHandler`接口的方法，从而触发`Button`的`onClick`事件** ，如下图所示\n\n![](https://pic3.zhimg.com/80/v2-1e8f7c467c473bd3b3315b3b6be8280a_720w.jpg)\n\n继续往上找，`ExecuteEvents`类中还定义了一个`EventFunction<T1>`的泛型委托以及该委托类型的属性，这个返回`s_PointerClickHandler`，要查找谁触发的点击事件，只需要找到谁调用了`pointerClickHandler`即可\n\n```csharp\npublic delegate void EventFunction<T1>(T1 handler, BaseEventData eventData);\npublic static EventFunction<IPointerClickHandler> pointerClickHandler\n{\n    get { return s_PointerClickHandler; }\n}\n```\n\n容易发现，`StandaloneInputModule`和`TouchInputModule`类对其有调用，这两个类继承自`BaseInput`，主要用以处理鼠标、键盘、控制器等设备的输入， **`EventSystem`类会在`Update`中每帧检查可用的输入模块的状态是否发生变化，并调用`TickModules()`和当前输入模块(`m_CurrentInputModule`)的`Process()`函数** (后面会进行讲解)。下面是`StandaloneInputModule`的部分代码，它继承自`BaseInputModule`\n\n```csharp\n// 计算和处理任何鼠标按钮状态的变化\n//Process函数间接对其进行调用（调用链过长，不一一展示)\nprotected void ProcessMousePress(MouseButtonEventData data)\n{\n    ...//省略部分代码\n       //鼠标按键抬起时调用（按键包括鼠标左键、中间滑轮和右键）\n    if (data.ReleasedThisFrame())\n    {\n        ReleaseMouse(pointerEvent, currentOverGo);\n    }\n    ...\n}\n\n//满足松开鼠标的条件时调用\n//currentOverGo ：当前选中的游戏物体\nprivate void ReleaseMouse(PointerEventData pointerEvent, GameObject currentOverGo)\n{\n    ...//省略部分代码\n    if (pointerEvent.pointerPress == pointerUpHandler && pointerEvent.eligibleForClick)\n    {\n        //执行Execute函数，传入ExecuteEvents.pointerClickHandler委托\n        ExecuteEvents.Execute(pointerEvent.pointerPress, pointerEvent, ExecuteEvents.pointerClickHandler);\n    }  \n    ...\n}\n```\n\n查看`ExecuteEvents.Execute`的实现\n\n> 上面已经查看过`Execute`方法，为什么现在又出来一个？\n> 因为`ExecuteEvents`中有N多个重载函数\n\n```csharp\n//target ： 需要执行事件的游戏对象\npublic static bool Execute<T>(GameObject target, BaseEventData eventData, EventFunction<T> functor) where T : IEventSystemHandler\n{\n    var internalHandlers = s_HandlerListPool.Get();\n    //获取target对象的事件\n    GetEventList<T>(target, internalHandlers);\n    //  if (s_InternalHandlers.Count > 0)\n    //      Debug.Log(\"Executinng \" + typeof (T) + \" on \" + target);\n\n    for (var i = 0; i < internalHandlers.Count; i++)\n    {\n        T arg;\n        try\n        {\n            arg = (T)internalHandlers[i];\n        }\n        catch (Exception e)\n        {\n            var temp = internalHandlers[i];\n            Debug.LogException(new Exception(string.Format(\"Type {0} expected {1} received.\", typeof(T).Name, temp.GetType().Name), e));\n            continue;\n        }\n\n        try\n        {\n            //执行EventFunction<T>委托,例如pointerClickHandler(arg,eventData)\n            functor(arg, eventData);\n        }\n        catch (Exception e)\n        {\n            Debug.LogException(e);\n        }\n    }\n\n    var handlerCount = internalHandlers.Count;\n    s_HandlerListPool.Release(internalHandlers);\n    return handlerCount > 0;\n}\n```\n\n**也就是说，`EventSystem`会在`Update()`中调用当前可用`BaseInputModule`的`Process()`方法，该方法会处理鼠标的按下、抬起等事件，当鼠标抬起时调用`ReleaseMouse()`方法，并最终调用`Execute()`方法并触发`IPointerClick`事件。** 如下图所示(为了简洁，类图并不完整)\n\n![](https://pic2.zhimg.com/80/v2-271819772d80baa805565dc9182d3ab5_720w.jpg)\n\n> ReleaseMouse()是否只有鼠标左键抬起才会触发？\n> 鼠标左、中、右键都会触发该函数，只不过`Button`在实现`OnPointerClick()`函数时忽略了鼠标中键和右键，使得只有左键能触发`Button`的点击事件\n\n但现在还存在一个问题，怎么知道上述代码中事件执行目标`target`的值呢？探究这个问题之前，我们需要先对`UGUI`源码有个总体的认识，因为它涉及的知识点比较多。\n\n## **事件系统整体概述**\n\n我们先看`EventSystem`源码在文件夹中的分类\n\n![](https://pic4.zhimg.com/80/v2-15edd68d6268be3dd761ac92e6b6961b_720w.jpg)\n\n从图中就可以看出主要 **包含三个子板块，分别是`EvnetData`、`InputModules`和`Raycasters`** 。\n\n再看一个整体的类图，类图中包括了许多重要的类，如`EventSystem`、`BaseRaycast`、`BaseInputModule`等，它们都是继承自`UIBehaviour`，而`UIBehaviour`又是继承`MonoBehaviour`。（类图并不完整，只涉及部分类）\n\n![](https://pic4.zhimg.com/80/v2-d401d582568a761d54f89a64a8371a93_720w.jpg)\n\n接下来对这些内容进行详细讲解。\n\n### **`EventSystem`类**\n\n事件系统主要是 **基于输入(键盘、鼠标、触摸或自定义输入)向应用程序中的对象发送事件** ，当然这需要其他组件的配合。当你在`GameObject`中添加`EventSystem`时，你会发现它并没有太多的功能，这是因为 **`EventSystem`本身被设计成事件系统不同模块之间通信的管理者和推动者** ，它主要包含以下功能：\n\n* **管理哪个游戏对象被认为是选中的**\n* **管理正在使用的输入模块**\n* **管理射线检测(如果需要)**\n* **根据需要更新所有输入模块**\n\n### 管理输入模块\n\n下面看一下具体代码。首先是声明了`BaseInputModule`类型的`List`和变量，用来保存输入模块(`Module`)\n\n```csharp\n//系统输入模块\nprivate List<BaseInputModule> m_SystemInputModules = new List<BaseInputModule>();\n//当前输入模块\nprivate BaseInputModule m_CurrentInputModule;\n```\n\n接下来，它会在`Update`中处理这些模块，调用`TickModules`方法，更新每一个模块，并且会在满足条件的情况下调用当前模块的`Process`方法\n\n```csharp\n protected virtual void Update()\n {\n    //遍历m_SystemInputModules，如果其中的Module不为null，则调用UpdateModule方法\n     TickModules();\n\n     //遍历m_SystemInputModules判断其中的输入模块是否支持当前平台\n     //如果支持并且可以激活，则将其赋值给当前输入模块并Break\n     bool changedModule = false;\n     var systemInputModulesCount = m_SystemInputModules.Count;\n     for (var i = 0; i < systemInputModulesCount; i++)\n     {\n         var module = m_SystemInputModules[i];\n         if (module.IsModuleSupported() && module.ShouldActivateModule())\n         {\n             if (m_CurrentInputModule != module)\n             {\n                 ChangeEventModule(module);\n                 changedModule = true;\n             }\n             break;\n         }\n     }\n\n     //如果上面没找到符合条件的模块，则使用第一个支持当前平台的模块\n     if (m_CurrentInputModule == null)\n     {\n         for (var i = 0; i < systemInputModulesCount; i++)\n         {\n             var module = m_SystemInputModules[i];\n             if (module.IsModuleSupported())\n             {\n                 ChangeEventModule(module);\n                 changedModule = true;\n                 break;\n             }\n         }\n     }\n\n     //如果当前模块没有发生变化并且当前模块不为空\n     if (!changedModule && m_CurrentInputModule != null)\n         m_CurrentInputModule.Process();\n }\n\nprivate void TickModules()\n{\n    var systemInputModulesCount = m_SystemInputModules.Count;\n    for (var i = 0; i < systemInputModulesCount; i++)\n    {\n        if (m_SystemInputModules[i] != null)\n            m_SystemInputModules[i].UpdateModule();\n    }\n}\n```\n\n`Process()`方法主要是将各种输入事件（如点击、拖拽等事件）传递给`EventSystem`当前选中的`GameObject`(即`m_CurrentSelected`)\n\n### 管理选中的游戏对象\n\n当场景中的游戏物体(`Button`、`Dropdown`、`InputField`等)被选中时，会通知之前选中的对象执行被取消(`OnDeselect`)事件，通知当前选中的对象执行选中(`OnSelect`)事件，部分代码如下\n\n```csharp\npublic void SetSelectedGameObject(GameObject selected, BaseEventData pointer)\n{\n    ......//省略部分代码\n    //通知之前被选中取消选中\n    ExecuteEvents.Execute(m_CurrentSelected, pointer, ExecuteEvents.deselectHandler);\n    m_CurrentSelected = selected;\n    //通知当前物体被选中\n    ExecuteEvents.Execute(m_CurrentSelected, pointer, ExecuteEvents.selectHandler);\n    m_SelectionGuard = false;\n}\n```\n\n### 管理射线检测\n\n`EventSystem`中，还有一个非常重要的函数`RaycastAll()`，主要是获取目标。它被`PointerInputModule`类调用，大致来说是当鼠标设备可用或触摸板被使用时调用。\n\n```csharp\npublic void RaycastAll(PointerEventData eventData, List<RaycastResult> raycastResults)\n {\n     raycastResults.Clear();\n     //获取BaseRaycast对象\n     var modules = RaycasterManager.GetRaycasters();\n     var modulesCount = modules.Count;\n     for (int i = 0; i < modulesCount; ++i)\n     {\n         var module = modules[i];\n         if (module == null || !module.IsActive())\n             continue;\n        //调用Raycast方法，\n         module.Raycast(eventData, raycastResults);\n     }\n\n     raycastResults.Sort(s_RaycastComparer);\n }\n```\n\n它首先获取所有的`BaseRaycast`对象，然后调用它的`Raycast`方法，用以获取屏幕某个点下的所有目标（这个方法具体功能及实现的会在`Raycast`模块中进行讲解)，最后对得到的结果进行排序，大部分情况都是根据深度(`Depth`)进行排序，在一些情况下也会使用距离(`Distance`)、排序顺序(`SortingOrder`，如果是`UI`元素则是根据`Canvas`面板的`Sort order`值，`3D`物体默认是0)或者排序层级(`Sorting Layer`)等作为排序依据。\n\n讲了这么一大堆，来张图总结一下。**`EventSystem`会在`Update`中调用输入模块的`Process`方法来处理输入消息，`PointerInputModule`会调用`EventSystem`中的`RaycastAll`方法进行射线检测，`RaycastAll`又会调用`BastRaycaster`的`Raycast`方法执行具体的射线检测操作，主要是获取被选中的目标信息。**\n\n![](https://pic4.zhimg.com/80/v2-9685293899700c01f1d93245f0deda87_720w.jpg)\n\n简单概括一下`UML`图的含义，比如实线+三角形表示继承，实线+箭头表示关联，虚线+箭头表示依赖，关联和依赖的区别主要是引用其他类作为成员变量代表的是关联关系，将其他类作为局部变量、方法参数，或者引用它的静态方法，就属于依赖关系。\n\n### **`InputModules`**\n\n输入模块是配置和定制事件系统主逻辑的地方。 自带的输入模块有两个，一个是为独立输入(`StandaloneInputModule`)，另一个是为触摸输入(`TouchInputModule`)。 `StandaloneInputModule`是`PC`、`Mac&Linux`上的具体实现，而`TouchInputModule`是`IOS`、`Android`等移动平台上的具体实现，每个模块都按照给定配置接收和分派事件。 运行`EventSystem`后，它会查看附加了哪些输入模块，并将事件传递给特定的模块。 内置的输入模块旨在支持常见的游戏配置，如触摸输入、控制器输入、键盘输入和鼠标输入等。\n\n它的主要任务有三个，分别是\n\n* **处理输入**\n* **管理事件状态**\n* **发送事件到场景对象**\n\n在讲`Button`的时候我们提到鼠标的点击事件是在`BaseInputModule`中触发的，除此之外，`EventInterface`接口中的其他事件也都是由输入模块产生的，具体触发条件如下：\n\n* 当鼠标或触摸进入、退出当前对象时执行`pointerEnterHandler`、`pointerExitHandler`。\n* 在鼠标或者触摸按下、松开时执行`pointerDownHandler`、`pointerUpHandler`。\n* 在鼠标或触摸松开并且与按下时是同一个响应物体时执行`pointerClickHandler`。\n* 在鼠标或触摸位置发生偏移（偏移值大于一个很小的常量）时执行`beginDragHandler`。\n* 在鼠标或者触摸按下且当前对象可以响应拖拽事件时执行`initializePotentialDrag`。\n* 对象正在被拖拽且鼠标或触摸移动时执行`dragHandler`。\n* 对象正在被拖拽且鼠标或触摸松开时执行`endDragHandler`。\n* 鼠标或触摸松开且对象未响应`pointerClickHandler`情况下，如果对象正在被拖拽，执行`dropHandler`。\n* 当鼠标滚动差值大于零执行`scrollHandler`。\n* 当输入模块切换到`StandaloneInputModule`时执行`updateSelectedHandler`。（不需要Input类）\n* 当鼠标移动导致被选中的对象改变时，执行`selectHandler`和`deselectHandler`。\n* 导航事件可用情况下，按下上下左右键，执行`moveHandler`，按下确认键执行`submitHandler`，按下取消键执行`cancelHandler`。\n\n更加底层的调用还是`UnityEngine.Input`类，但可惜的是这部分`Unity`并没有开源。\n\n> 每次事件系统中只能有一个输入模块处于活跃状态，并且必须与`EventSystem`组件处于相同的游戏对象上。\n\n### 执行事件\n\n既然`InputModule`主要就是处理设备输入，发送事件到场景对象，那这些事件是怎么执行的呢？在讲`Button`的时候，我们提到过`ExecuteEvent`类，其实事件的执行都是通过这个类进行的，不过也需要`EventInterface`接口配合。这个类中定义了许多接口，比如鼠标按下、点击、拖拽等，下图展示了部分接口的继承关系。\n\n![](https://pic4.zhimg.com/80/v2-cfeebe5f05d3c8aa3dbe72fb99501913_720w.jpg)\n\n`ExecuteEvent`类中提供了一个方法让外部统一调用以执行事件\n\n```csharp\npublic static bool Execute<T>(GameObject target, BaseEventData eventData, EventFunction<T> functor) where T : IEventSystemHandler\n{\n    //从对象池中取出一个IEventSystemHandler类型的元素\n    var internalHandlers = s_HandlerListPool.Get();\n    //获取指定对象(target)的事件,并保存在internalHandlers中\n    GetEventList<T>(target, internalHandlers);\n    //  if (s_InternalHandlers.Count > 0)\n    //      Debug.Log(\"Executinng \" + typeof (T) + \" on \" + target);\n\n    var internalHandlersCount = internalHandlers.Count;\n    for (var i = 0; i < internalHandlersCount; i++)\n    {\n        T arg;\n        try\n        {\n            arg = (T)internalHandlers[i];\n        }\n        catch (Exception e)\n        {\n            var temp = internalHandlers[i];\n            Debug.LogException(new Exception(string.Format(\"Type {0} expected {1} received.\", typeof(T).Name, temp.GetType().Name), e));\n            continue;\n        }\n\n        try\n        {\n            //执行事件\n            functor(arg, eventData);\n        }\n        catch (Exception e)\n        {\n            Debug.LogException(e);\n        }\n    }\n\n    var handlerCount = internalHandlers.Count;\n    s_HandlerListPool.Release(internalHandlers);\n    return handlerCount > 0;\n}\n```\n\n这个方法之前有讲过，主要就是查找`target`对象上的`T`类型的组件列表，并遍历执行。\n\n除此之外，还有一个`GetEventHandler`方法，它主要是通过冒泡的方式查找到能够处理指定事件的对象。\n\n```csharp\n// 在游戏对象上冒泡指定的事件，找出哪个对象将实际接收事件。 \npublic static GameObject GetEventHandler<T>(GameObject root) where T : IEventSystemHandler\n{\n    if (root == null)\n        return null;\n\n    Transform t = root.transform;\n    //冒泡查找,如果物体本身不能处理输入的事件,交予parent处理\n    while (t != null)\n    {\n        if (CanHandleEvent<T>(t.gameObject))\n            return t.gameObject;\n        t = t.parent;\n    }\n  \n    return null;\n}\n\n // 指定的游戏对象是否能够处理指定的事件\n public static bool CanHandleEvent<T>(GameObject go) where T : IEventSystemHandler\n {\n     var internalHandlers = s_HandlerListPool.Get();\n     GetEventList<T>(go, internalHandlers);\n     var handlerCount = internalHandlers.Count;\n     s_HandlerListPool.Release(internalHandlers);\n     return handlerCount != 0;\n }\n```\n\n比如我们在场景中创建一个`Button`，那这个`Button`还包含了Text组件，当鼠标点击的时候会调用`GetEventHandler`函数，该函数的`root`参数其实是`Text`，但是会通过冒泡的方式查找到它的父物体`Button`，然后调用`Button`的点击事件。\n\n### **`Raycasters`**\n\n事件系统需要一个方法来检测当前输入事件需要发送到哪里，这是由`Raycasters`提供的。 给定一个屏幕空间位置，它们将收集所有潜在目标，找出它们是否在给定位置下，然后返回离屏幕最近的对象。 系统提供了以下几种类型的`Raycaster`:\n\n* **`Graphic Raycaster：` 检测`UI`元素**\n* **`Physics 2D Raycaster：` 用于`2D`物理元素**\n* **`Physics Raycaster：` 用于`3D`物理元素**\n\n![](https://pic3.zhimg.com/80/v2-bd2f8a5e377ab90e25e1d70392f418ee_720w.jpg)\n\n`BaseRaycaster`是其他`Raycaster`的基类，这是是一个抽象类。在它`OnEnable`里将自己注册到`RaycasterManager`，并在`OnDisable`的时候从后者移除。\n\n`RaycasterManager`是一个静态类，维护了一个`BaseRaycaster`类型的`List`，功能比较简单，包含获取(`Get`)、添加(`Add`)、移除(`Remove`)方法。\n\n`BaseRaycaster`中最重要的就是`Raycast`方法了，它的子类都对该方法进行了重写。\n\n### `Physics Raycaster`\n\n它主要用于检测`3D`物理元素，并且保存被射线检测到物体的数据，下面是部分代码\n\n```csharp\npublic override void Raycast(PointerEventData eventData, List<RaycastResult> resultAppendList)\n{\n    //判断是否超出摄像机的远近裁剪平面的距离\n    if (!ComputeRayAndDistance(eventData, ref ray, ref displayIndex, ref distanceToClipPlane))\n        return;\n\n    //采用ReflectionMethodsCache.Singleton.raycast3DAll()来获取所有射线照射到的对象\n    //用反射的方式把Physics.RaycastAll()方法缓存下来，让Unity的Physics模块与UI模块，保持低耦合，没有过分依赖。\n    if (m_MaxRayIntersections == 0)\n    {\n        m_Hits = ReflectionMethodsCache.Singleton.raycast3DAll(ray, distanceToClipPlane, finalEventMask);\n        hitCount = m_Hits.Length;\n    }\n    else\n    {\n        if (m_LastMaxRayIntersections != m_MaxRayIntersections)\n        {\n            m_Hits = new RaycastHit[m_MaxRayIntersections];\n            m_LastMaxRayIntersections = m_MaxRayIntersections;\n        }\n\n        hitCount = ReflectionMethodsCache.Singleton.getRaycastNonAlloc(ray, m_Hits, distanceToClipPlane, finalEventMask);\n    }\n\n    //获取到被射线照射到的对象，根据距离进行排序，然后包装成RaycastResult,加入到resultAppendList中\n    if (hitCount != 0)\n    {\n        if (hitCount > 1)\n            System.Array.Sort(m_Hits, 0, hitCount, RaycastHitComparer.instance);\n\n        for (int b = 0, bmax = hitCount; b < bmax; ++b)\n        {\n            var result = new RaycastResult\n            {\n                ...//为result赋值\n            };\n            resultAppendList.Add(result);\n        }\n    }\n}\n```\n\n`Physics2DRaycaster`继承自`PhysicsRaycaster`，实现功能和方式基本一致，只不过是用于检测`2D`物体，这里不具体讲解\n\n### `GraphicRaycast`\n\n**`GraphicRaycast`用于检测`UI`元素，它依赖于`Canvas`，我们在场景中添加`Canvas`默认都会包含一个`GraphicRaycast`组件。它先获取鼠标坐标，将其转换为`Camera`的视角坐标，然后分情况计算射线的距离（`hitDistance`），调用`Graphic`的`Raycast`方法来获取鼠标点下方的元素，最后将满足条件的结果添加到`resultAppendList`中。**\n\n![](https://pic4.zhimg.com/80/v2-8bd60abc5511daada3c336a9aee12193_720w.jpg)\n\n一大波代码来袭，不感兴趣可以跳过\n\n```csharp\npublic override void Raycast(PointerEventData eventData, List<RaycastResult> resultAppendList)\n{\n    if (canvas == null)\n        return;\n\n    //返回Canvas上的所有包含Graphic脚本并且raycastTarget=true的游戏物体\n    var canvasGraphics = GraphicRegistry.GetRaycastableGraphicsForCanvas(canvas);\n\n    if (canvasGraphics == null || canvasGraphics.Count == 0)\n        return;\n\n    int displayIndex;\n    //画布在ScreenSpaceOverlay模式下默认为null\n    var currentEventCamera = eventCamera; // Property can call Camera.main, so cache the reference\n\n    if (canvas.renderMode == RenderMode.ScreenSpaceOverlay || currentEventCamera == null)\n        displayIndex = canvas.targetDisplay;\n    else\n        displayIndex = currentEventCamera.targetDisplay;\n\n    //获取鼠标位置\n    var eventPosition = Display.RelativeMouseAt(eventData.position);\n    if (eventPosition != Vector3.zero)\n    {\n        int eventDisplayIndex = (int)eventPosition.z;\n      \n        if (eventDisplayIndex != displayIndex)\n            return;\n    }\n    else\n    {\n        eventPosition = eventData.position;\n    }\n\n    // Convert to view space\n    //将鼠标点在屏幕上的坐标转换成摄像机的视角坐标,如果超出范围则return\n    Vector2 pos;\n    if (currentEventCamera == null)\n    {\n        float w = Screen.width;\n        float h = Screen.height;\n        if (displayIndex > 0 && displayIndex < Display.displays.Length)\n        {\n            w = Display.displays[displayIndex].systemWidth;\n            h = Display.displays[displayIndex].systemHeight;\n        }\n        pos = new Vector2(eventPosition.x / w, eventPosition.y / h);\n    }\n    else\n        pos = currentEventCamera.ScreenToViewportPoint(eventPosition);\n\n    // If it's outside the camera's viewport, do nothing\n    if (pos.x < 0f || pos.x > 1f || pos.y < 0f || pos.y > 1f)\n        return;\n\n    float hitDistance = float.MaxValue;\n\n    Ray ray = new Ray();\n\n    //如果currentEventCamera不为空,摄像机发射射线\n    if (currentEventCamera != null)\n        ray = currentEventCamera.ScreenPointToRay(eventPosition);\n\n    //如果当前画布不是ScreenSpaceOverlay模式并且blockingObjects != BlockingObjects.None\n    //计算hitDistance的值\n    if (canvas.renderMode != RenderMode.ScreenSpaceOverlay && blockingObjects != BlockingObjects.None)\n    {\n        float distanceToClipPlane = 100.0f;\n\n        if (currentEventCamera != null)\n        {\n            float projectionDirection = ray.direction.z;\n            distanceToClipPlane = Mathf.Approximately(0.0f, projectionDirection)\n                ? Mathf.Infinity\n                : Mathf.Abs((currentEventCamera.farClipPlane - currentEventCamera.nearClipPlane) / projectionDirection);\n        }\n        #if PACKAGE_PHYSICS\n            if (blockingObjects == BlockingObjects.ThreeD || blockingObjects == BlockingObjects.All)\n            {\n                if (ReflectionMethodsCache.Singleton.raycast3D != null)\n                {\n                    var hits = ReflectionMethodsCache.Singleton.raycast3DAll(ray, distanceToClipPlane, (int)m_BlockingMask);\n                    if (hits.Length > 0)\n                        hitDistance = hits[0].distance;\n                }\n            }\n        #endif\n            #if PACKAGE_PHYSICS2D\n            if (blockingObjects == BlockingObjects.TwoD || blockingObjects == BlockingObjects.All)\n            {\n                if (ReflectionMethodsCache.Singleton.raycast2D != null)\n                {\n                    var hits = ReflectionMethodsCache.Singleton.getRayIntersectionAll(ray, distanceToClipPlane, (int)m_BlockingMask);\n                    if (hits.Length > 0)\n                        hitDistance = hits[0].distance;\n                }\n            }\n        #endif\n    }\n\n    m_RaycastResults.Clear();\n\n    //调用Raycast函数重载\n    Raycast(canvas, currentEventCamera, eventPosition, canvasGraphics, m_RaycastResults);\n\n    //遍历m_RaycastResults，判断Graphic的方向向量和Camera的方向向量是否相交，然后判断Graphic是否在Camera的前面，并且距离小于等于hitDistance，满足了这些条件，才会把它打包成RaycastResult添加到resultAppendList里。\n    int totalCount = m_RaycastResults.Count;\n    for (var index = 0; index < totalCount; index++)\n    {\n        var go = m_RaycastResults[index].gameObject;\n        bool appendGraphic = true;\n\n        if (ignoreReversedGraphics)\n        {\n            if (currentEventCamera == null)\n            {\n                // If we dont have a camera we know that we should always be facing forward\n                var dir = go.transform.rotation * Vector3.forward;\n                appendGraphic = Vector3.Dot(Vector3.forward, dir) > 0;\n            }\n            else\n            {\n                // If we have a camera compare the direction against the cameras forward.\n                var cameraForward = currentEventCamera.transform.rotation * Vector3.forward * currentEventCamera.nearClipPlane;\n                appendGraphic = Vector3.Dot(go.transform.position - currentEventCamera.transform.position - cameraForward, go.transform.forward) >= 0;\n            }\n        }\n\n        if (appendGraphic)\n        {\n            float distance = 0;\n            Transform trans = go.transform;\n            Vector3 transForward = trans.forward;\n\n            if (currentEventCamera == null || canvas.renderMode == RenderMode.ScreenSpaceOverlay)\n                distance = 0;\n            else\n            {\n                // http://geomalgorithms.com/a06-_intersect-2.html\n                distance = (Vector3.Dot(transForward, trans.position - ray.origin) / Vector3.Dot(transForward, ray.direction));\n\n                // Check to see if the go is behind the camera.\n                if (distance < 0)\n                    continue;\n            }\n\n            if (distance >= hitDistance)\n                continue;\n\n            var castResult = new RaycastResult\n            {\n                ......\n            };\n            resultAppendList.Add(castResult);\n        }\n    }\n```\n\n上述代码中调用了`Raycast`函数重载，作用是向屏幕投射射线并收集屏幕下方所有挂载了`Graphic`脚本的游戏对象，该函数内容为：\n\n```csharp\nprivate static void Raycast(Canvas canvas, Camera eventCamera, Vector2 pointerPosition, IList<Graphic> foundGraphics, List<Graphic> results)\n{\n    // Necessary for the event system\n    //遍历场景内Graphic对象(挂载Graphic脚本的对象)\n    int totalCount = foundGraphics.Count;\n    for (int i = 0; i < totalCount; ++i)\n    {\n        Graphic graphic = foundGraphics[i];\n\n        // -1 means it hasn't been processed by the canvas, which means it isn't actually drawn\n        if (!graphic.raycastTarget || graphic.canvasRenderer.cull || graphic.depth == -1)\n            continue;\n\n        //目标点是否在矩阵中\n        if (!RectTransformUtility.RectangleContainsScreenPoint(graphic.rectTransform, pointerPosition, eventCamera, graphic.raycastPadding))\n            continue;\n\n        //超出摄像机范围\n        if (eventCamera != null && eventCamera.WorldToScreenPoint(graphic.rectTransform.position).z > eventCamera.farClipPlane)\n            continue;\n\n        //调用符合条件的Graphic的Raycast方法\n        if (graphic.Raycast(pointerPosition, eventCamera))\n        {\n            s_SortedGraphics.Add(graphic);\n        }\n    }\n\n    s_SortedGraphics.Sort((g1, g2) => g2.depth.CompareTo(g1.depth));\n    totalCount = s_SortedGraphics.Count;\n    for (int i = 0; i < totalCount; ++i)\n        results.Add(s_SortedGraphics[i]);\n\n    s_SortedGraphics.Clear();\n}\n```\n\n **函数中又调用了`Graphic`类的`Raycast`函数，它主要是做两件事，一件是使用`RectTransform`的值过滤元素，另一件是使用`Raycast`函数确定射线击中的元素。** `RawImage`、`Image`和`Text`都间接继承自`Graphic`。\n\n![](https://pic2.zhimg.com/80/v2-b9be049e2a433d8a8437328d49e8dc4d_720w.jpg)\n\n```csharp\n public virtual bool Raycast(Vector2 sp, Camera eventCamera)\n {\n     if (!isActiveAndEnabled)\n         return false;\n\n     //UI元素,比如Image,Button等\n     var t = transform;\n\n     var components = ListPool<Component>.Get();\n\n     bool ignoreParentGroups = false;\n     bool continueTraversal = true;\n\n     while (t != null)\n     {\n         t.GetComponents(components);\n         for (var i = 0; i < components.Count; i++)\n         {\n\n             Debug.Log(components[i].name);\n             var canvas = components[i] as Canvas;\n             if (canvas != null && canvas.overrideSorting)\n                 continueTraversal = false;\n\n             //获取ICanvasRaycastFilter组件(Image,Mask,RectMask2D)\n             var filter = components[i] as ICanvasRaycastFilter;\n\n             if (filter == null)\n                 continue;\n\n             var raycastValid = true;\n\n             //判断sp点是否在有效的范围内\n             var group = components[i] as CanvasGroup;\n             if (group != null)\n             {\n                 if (ignoreParentGroups == false && group.ignoreParentGroups)\n                 {\n                     ignoreParentGroups = true;\n                     raycastValid = filter.IsRaycastLocationValid(sp, eventCamera);\n                 }\n                 else if (!ignoreParentGroups)\n                     raycastValid = filter.IsRaycastLocationValid(sp, eventCamera);\n             }\n             else\n             {\n                 raycastValid = filter.IsRaycastLocationValid(sp, eventCamera);\n             }\n\n             if (!raycastValid)\n             {\n                 ListPool<Component>.Release(components);\n                 return false;\n             }\n         }\n         //遍历它的父物体\n         t = continueTraversal ? t.parent : null;\n     }\n     ListPool<Component>.Release(components);\n     return true;\n }\n```\n\n这里也使用了`ICanvasRaycastFilter`接口中的`IsRaycastLocationValid`函数，主要还是判断点的位置是否有效，不过这里使用了Alpha测试。Image、Mask以及RectMask2D都继承了该接口。\n\n![](https://pic4.zhimg.com/80/v2-d80ee9c4b4f5c61ef1c05a1fc793bfab_720w.jpg)\n\n```csharp\n public virtual bool IsRaycastLocationValid(Vector2 screenPoint, Camera eventCamera)\n {\n     //小于阈值(alphaHitTestMinimumThreshold)的Alpha值将导致射线事件穿透图像。 \n     //值为1将导致只有完全不透明的像素在图像上注册相应射线事件。\n     if (alphaHitTestMinimumThreshold <= 0)\n         return true;\n\n     if (alphaHitTestMinimumThreshold > 1)\n         return false;\n\n     if (activeSprite == null)\n         return true;\n\n     Vector2 local;\n     if (!RectTransformUtility.ScreenPointToLocalPointInRectangle(rectTransform, screenPoint, eventCamera, out local))\n         return false;\n\n     Rect rect = GetPixelAdjustedRect();\n\n     // Convert to have lower left corner as reference point.\n     local.x += rectTransform.pivot.x * rect.width;\n     local.y += rectTransform.pivot.y * rect.height;\n\n     local = MapCoordinate(local, rect);\n\n     // Convert local coordinates to texture space.\n     Rect spriteRect = activeSprite.textureRect;\n     float x = (spriteRect.x + local.x) / activeSprite.texture.width;\n     float y = (spriteRect.y + local.y) / activeSprite.texture.height;\n\n     try\n     {\n         return activeSprite.texture.GetPixelBilinear(x, y).a >= alphaHitTestMinimumThreshold;\n     }\n     catch (UnityException e)\n     {\n         Debug.LogError(\"Using alphaHitTestMinimumThreshold greater than 0 on Image whose sprite texture cannot be read. \" + e.Message + \" Also make sure to disable sprite packing for this sprite.\", this);\n         return true;\n     }\n }\n```\n\n### `EventData`\n\n`EventData`用以存储事件信息，涉及到的东西不多，不展开讲解，层级关系如下图所示\n\n![](https://pic1.zhimg.com/80/v2-a72d1e210d9964fe63a440b4172d84ac_720w.jpg)\n\n## **实战：为Button的点击事件添加参数**\n\n在执行`Button`点击事件时，有些情况下我们需要获取触发事件的`Button`对象信息，这时可以自己实现一个`Button`点击事件\n\n```csharp\n/// <summary>\n/// UI事件监听器(与Button等UI挂在同一个物体上）：管理所有UGUI事件，提供事件参数类\n/// 若想看所有相关委托  自行查看EventTrigger类\n/// </summary>\npublic class UIEventListener : MonoBehaviour, IPointerClickHandler, IPointerDownHandler, IPointerUpHandler\n{\n    //2.定义委托\n    public delegate void PointerEventHandler(PointerEventData eventData);\n\n    //3.声明事件\n    public event PointerEventHandler PointerClick;\n    public event PointerEventHandler PointerDown;\n    public event PointerEventHandler PointerUp;\n\n    /// <summary>\n    /// 通过变换组件获取事件监听器\n    /// </summary>\n    /// <param name=\"transform\"></param>\n    /// <returns></returns>\n    public static UIEventListener GetEventListener(Transform transform)\n    {\n        UIEventListener uIEventListener = transform.GetComponent<UIEventListener>();\n\n        if (uIEventListener == null)\n            uIEventListener = transform.gameObject.AddComponent<UIEventListener>();\n\n        return uIEventListener;\n    }\n\n    //1.实现接口\n    public void OnPointerClick(PointerEventData eventData)\n    {\n        //表示抽象的有  抽象类  接口（多类抽象行为）  委托（一类抽象行为）\n        //4.引发事件\n        if (PointerClick != null)\n            PointerClick(eventData);\n    }\n\n    public void OnPointerDown(PointerEventData eventData)\n    {\n        PointerDown?.Invoke(eventData);\n    }\n\n    public void OnPointerUp(PointerEventData eventData)\n    {\n        PointerUp?.Invoke(eventData);\n    }\n}\n```\n\n使用的时候，我们只需要将它挂载到`Button`组件上，然后在`PointerClick`事件中添加自己的处理函数。\n\n## **总结**\n\n`Button`点击事件怎么触发的呢？首先是`EventSystem`在`Update`中调用当前输入模块的`Process`方法处理所有的鼠标事件，并且输入模块会调用`RaycastAll`来得到目标信息，通过冒泡的方式找到事件实际接收者并执行点击事件(这只是总体流程，中间省略很多具体步骤)。\n\n![](https://pic2.zhimg.com/80/v2-46b1ca8927625fb9ffb2cf94092b4651_720w.jpg)\n\n最后来一张层级关系图\n\n![](https://pic2.zhimg.com/80/v2-9a23d2a2f220e3e8100607ddc0999721_720w.jpg)","source":"_posts/UGUI源码解析-1.md","raw":"---\ntitle: UGUI源码解析(1)\ndate: 2022-03-15 23:04:38\ntags:\n- [program]\ncategories:\n- [program]\n---\n\n## **01 | 从`Button`开始解读`UGUI`源码**\n\n在Unity中，Button是我们最常用的组件之一了，它使用起来非常简单，例如监听一个Button点击事件\n\n```csharp\nGetComponent<Button>().onClick.AddListener(() => { \n    ...//按钮点击的处理逻辑\n});\n```\n\n这样使用没有任何问题，但有时候我们会有疑问，为什么点击按钮`onClick`事件就会被触发呢？如何从回调函数中获取按钮的参数？让我们从源码中寻找答案。\n\n## **查看源码前的配置**\n\n为了能够方便的查阅源码以及进行代码调试，需要重新导入`UGUI`包。新建Unity项目，找到`Project/Packages/Unity UI`，右键 `Show in Explorer`，将其复制到任意一个新的文件夹中(记住保存的位置，待会需要引用)。\n\n接下来打开`Window/Package Manager`\n\n![](https://pic1.zhimg.com/80/v2-3ccfbcede96e7528a3b02780975fa198_720w.jpg)\n\n找到`Unity UI`，将其`Remove`\n\n![](https://pic1.zhimg.com/80/v2-2f23bd59190b84d78c1249ac0ebde634_720w.jpg)\n\n然后点击`“+”`号，选择`Add package form disk...`，找到之前保存的UI包，进入目录后选中`package.json`，点击打开。\n\n![](https://pic1.zhimg.com/80/v2-63a9b186c1eaf811361227c1e2d752e0_720w.jpg)\n\n大功告成，现在我们可以查看/修改`UGUI`的源码了。\n\n## **探究`UGUI`源码**\n\n### **`Button`的调用链**\n\n通过`F12`打开`Button`代码，容易发现它继承`Selectable`类，同时还继承了`IPointerClickHandler`、`ISubmitHandler`接口，这两个接口分别会在鼠标点击、点击提交按钮时调用它们的回调函数。\n\n```text\n public class Button : Selectable, IPointerClickHandler, ISubmitHandler\n {\n     [Serializable]\n     //定义一个点击事件\n     public class ButtonClickedEvent : UnityEvent {}\n\n     // 实例化一个ButtonClickedEvent的事件\n     [FormerlySerializedAs(\"onClick\")]\n     [SerializeField]\n     private ButtonClickedEvent m_OnClick = new ButtonClickedEvent();\n\n     protected Button()\n     {}\n  \n     //常用的onClick.AddListener()就是监听这个事件\n     public ButtonClickedEvent onClick\n     {\n         get { return m_OnClick; }\n         set { m_OnClick = value; }\n     }\n   \n     //如果按钮处于活跃状态并且可交互(Interactable设置为true)，则触发事件\n     private void Press()\n     {\n         if (!IsActive() || !IsInteractable())\n             return;\n\n         UISystemProfilerApi.AddMarker(\"Button.onClick\", this);\n         m_OnClick.Invoke();\n     }\n  \n     //鼠标点击时调用该函数，继承自 IPointerClickHandler 接口\n     public virtual void OnPointerClick(PointerEventData eventData)\n     {\n         if (eventData.button != PointerEventData.InputButton.Left)\n             return;\n\n         Press();\n     }\n  \n     //按下“提交”键后触发(需要先选中该游戏物体)，继承自 ISubmitHandler\n     //\"提交\"键可以在 Edit->Project Settings->Input->Submit 中自定义\n     public virtual void OnSubmit(BaseEventData eventData){...}\n\n     private IEnumerator OnFinishSubmit(){...}\n}\n```\n\n`IPointerClickHandler`接口仅包含一个`OnPointerClick()`方法，当鼠标点击时会调用该接口的方法。而`Button`能触发点击事件是因为继承自`IPointerClickHandler`接口，并且重写了`OnPointerClick`方法。\n\n那`IPointerClickHandler`接口的方法又是被谁调用的呢？查找引用，发现是`ExecuteEvents`类的`Execute`方法(该类相当于事件执行器，提供了许多通用的事件处理方法)，并且`Execute`方法赋值给`s_PointerClickHandler`字段。\n\n```csharp\nprivate static readonly EventFunction<IPointerClickHandler> s_PointerClickHandler = Execute;\nprivate static void Execute(IPointerClickHandler handler, BaseEventData eventData)\n{\n    handler.OnPointerClick(ValidateEventData<PointerEventData>(eventData));\n}\n```\n\n **为了能看的更清楚，总结一下调用关系，即`Button`继承自`Selectable`、`IPointercliClickHandler`、`ISubmitHandler`，而`IPointercliClickHandler`、`ISubmitHandler`继承自`IEventSystemHandler`，`ExecuteEvent`会在鼠标松开时通过`Execute`函数调用`IPointercliClickHandler`、`ISubmitHandler`接口的方法，从而触发`Button`的`onClick`事件** ，如下图所示\n\n![](https://pic3.zhimg.com/80/v2-1e8f7c467c473bd3b3315b3b6be8280a_720w.jpg)\n\n继续往上找，`ExecuteEvents`类中还定义了一个`EventFunction<T1>`的泛型委托以及该委托类型的属性，这个返回`s_PointerClickHandler`，要查找谁触发的点击事件，只需要找到谁调用了`pointerClickHandler`即可\n\n```csharp\npublic delegate void EventFunction<T1>(T1 handler, BaseEventData eventData);\npublic static EventFunction<IPointerClickHandler> pointerClickHandler\n{\n    get { return s_PointerClickHandler; }\n}\n```\n\n容易发现，`StandaloneInputModule`和`TouchInputModule`类对其有调用，这两个类继承自`BaseInput`，主要用以处理鼠标、键盘、控制器等设备的输入， **`EventSystem`类会在`Update`中每帧检查可用的输入模块的状态是否发生变化，并调用`TickModules()`和当前输入模块(`m_CurrentInputModule`)的`Process()`函数** (后面会进行讲解)。下面是`StandaloneInputModule`的部分代码，它继承自`BaseInputModule`\n\n```csharp\n// 计算和处理任何鼠标按钮状态的变化\n//Process函数间接对其进行调用（调用链过长，不一一展示)\nprotected void ProcessMousePress(MouseButtonEventData data)\n{\n    ...//省略部分代码\n       //鼠标按键抬起时调用（按键包括鼠标左键、中间滑轮和右键）\n    if (data.ReleasedThisFrame())\n    {\n        ReleaseMouse(pointerEvent, currentOverGo);\n    }\n    ...\n}\n\n//满足松开鼠标的条件时调用\n//currentOverGo ：当前选中的游戏物体\nprivate void ReleaseMouse(PointerEventData pointerEvent, GameObject currentOverGo)\n{\n    ...//省略部分代码\n    if (pointerEvent.pointerPress == pointerUpHandler && pointerEvent.eligibleForClick)\n    {\n        //执行Execute函数，传入ExecuteEvents.pointerClickHandler委托\n        ExecuteEvents.Execute(pointerEvent.pointerPress, pointerEvent, ExecuteEvents.pointerClickHandler);\n    }  \n    ...\n}\n```\n\n查看`ExecuteEvents.Execute`的实现\n\n> 上面已经查看过`Execute`方法，为什么现在又出来一个？\n> 因为`ExecuteEvents`中有N多个重载函数\n\n```csharp\n//target ： 需要执行事件的游戏对象\npublic static bool Execute<T>(GameObject target, BaseEventData eventData, EventFunction<T> functor) where T : IEventSystemHandler\n{\n    var internalHandlers = s_HandlerListPool.Get();\n    //获取target对象的事件\n    GetEventList<T>(target, internalHandlers);\n    //  if (s_InternalHandlers.Count > 0)\n    //      Debug.Log(\"Executinng \" + typeof (T) + \" on \" + target);\n\n    for (var i = 0; i < internalHandlers.Count; i++)\n    {\n        T arg;\n        try\n        {\n            arg = (T)internalHandlers[i];\n        }\n        catch (Exception e)\n        {\n            var temp = internalHandlers[i];\n            Debug.LogException(new Exception(string.Format(\"Type {0} expected {1} received.\", typeof(T).Name, temp.GetType().Name), e));\n            continue;\n        }\n\n        try\n        {\n            //执行EventFunction<T>委托,例如pointerClickHandler(arg,eventData)\n            functor(arg, eventData);\n        }\n        catch (Exception e)\n        {\n            Debug.LogException(e);\n        }\n    }\n\n    var handlerCount = internalHandlers.Count;\n    s_HandlerListPool.Release(internalHandlers);\n    return handlerCount > 0;\n}\n```\n\n**也就是说，`EventSystem`会在`Update()`中调用当前可用`BaseInputModule`的`Process()`方法，该方法会处理鼠标的按下、抬起等事件，当鼠标抬起时调用`ReleaseMouse()`方法，并最终调用`Execute()`方法并触发`IPointerClick`事件。** 如下图所示(为了简洁，类图并不完整)\n\n![](https://pic2.zhimg.com/80/v2-271819772d80baa805565dc9182d3ab5_720w.jpg)\n\n> ReleaseMouse()是否只有鼠标左键抬起才会触发？\n> 鼠标左、中、右键都会触发该函数，只不过`Button`在实现`OnPointerClick()`函数时忽略了鼠标中键和右键，使得只有左键能触发`Button`的点击事件\n\n但现在还存在一个问题，怎么知道上述代码中事件执行目标`target`的值呢？探究这个问题之前，我们需要先对`UGUI`源码有个总体的认识，因为它涉及的知识点比较多。\n\n## **事件系统整体概述**\n\n我们先看`EventSystem`源码在文件夹中的分类\n\n![](https://pic4.zhimg.com/80/v2-15edd68d6268be3dd761ac92e6b6961b_720w.jpg)\n\n从图中就可以看出主要 **包含三个子板块，分别是`EvnetData`、`InputModules`和`Raycasters`** 。\n\n再看一个整体的类图，类图中包括了许多重要的类，如`EventSystem`、`BaseRaycast`、`BaseInputModule`等，它们都是继承自`UIBehaviour`，而`UIBehaviour`又是继承`MonoBehaviour`。（类图并不完整，只涉及部分类）\n\n![](https://pic4.zhimg.com/80/v2-d401d582568a761d54f89a64a8371a93_720w.jpg)\n\n接下来对这些内容进行详细讲解。\n\n### **`EventSystem`类**\n\n事件系统主要是 **基于输入(键盘、鼠标、触摸或自定义输入)向应用程序中的对象发送事件** ，当然这需要其他组件的配合。当你在`GameObject`中添加`EventSystem`时，你会发现它并没有太多的功能，这是因为 **`EventSystem`本身被设计成事件系统不同模块之间通信的管理者和推动者** ，它主要包含以下功能：\n\n* **管理哪个游戏对象被认为是选中的**\n* **管理正在使用的输入模块**\n* **管理射线检测(如果需要)**\n* **根据需要更新所有输入模块**\n\n### 管理输入模块\n\n下面看一下具体代码。首先是声明了`BaseInputModule`类型的`List`和变量，用来保存输入模块(`Module`)\n\n```csharp\n//系统输入模块\nprivate List<BaseInputModule> m_SystemInputModules = new List<BaseInputModule>();\n//当前输入模块\nprivate BaseInputModule m_CurrentInputModule;\n```\n\n接下来，它会在`Update`中处理这些模块，调用`TickModules`方法，更新每一个模块，并且会在满足条件的情况下调用当前模块的`Process`方法\n\n```csharp\n protected virtual void Update()\n {\n    //遍历m_SystemInputModules，如果其中的Module不为null，则调用UpdateModule方法\n     TickModules();\n\n     //遍历m_SystemInputModules判断其中的输入模块是否支持当前平台\n     //如果支持并且可以激活，则将其赋值给当前输入模块并Break\n     bool changedModule = false;\n     var systemInputModulesCount = m_SystemInputModules.Count;\n     for (var i = 0; i < systemInputModulesCount; i++)\n     {\n         var module = m_SystemInputModules[i];\n         if (module.IsModuleSupported() && module.ShouldActivateModule())\n         {\n             if (m_CurrentInputModule != module)\n             {\n                 ChangeEventModule(module);\n                 changedModule = true;\n             }\n             break;\n         }\n     }\n\n     //如果上面没找到符合条件的模块，则使用第一个支持当前平台的模块\n     if (m_CurrentInputModule == null)\n     {\n         for (var i = 0; i < systemInputModulesCount; i++)\n         {\n             var module = m_SystemInputModules[i];\n             if (module.IsModuleSupported())\n             {\n                 ChangeEventModule(module);\n                 changedModule = true;\n                 break;\n             }\n         }\n     }\n\n     //如果当前模块没有发生变化并且当前模块不为空\n     if (!changedModule && m_CurrentInputModule != null)\n         m_CurrentInputModule.Process();\n }\n\nprivate void TickModules()\n{\n    var systemInputModulesCount = m_SystemInputModules.Count;\n    for (var i = 0; i < systemInputModulesCount; i++)\n    {\n        if (m_SystemInputModules[i] != null)\n            m_SystemInputModules[i].UpdateModule();\n    }\n}\n```\n\n`Process()`方法主要是将各种输入事件（如点击、拖拽等事件）传递给`EventSystem`当前选中的`GameObject`(即`m_CurrentSelected`)\n\n### 管理选中的游戏对象\n\n当场景中的游戏物体(`Button`、`Dropdown`、`InputField`等)被选中时，会通知之前选中的对象执行被取消(`OnDeselect`)事件，通知当前选中的对象执行选中(`OnSelect`)事件，部分代码如下\n\n```csharp\npublic void SetSelectedGameObject(GameObject selected, BaseEventData pointer)\n{\n    ......//省略部分代码\n    //通知之前被选中取消选中\n    ExecuteEvents.Execute(m_CurrentSelected, pointer, ExecuteEvents.deselectHandler);\n    m_CurrentSelected = selected;\n    //通知当前物体被选中\n    ExecuteEvents.Execute(m_CurrentSelected, pointer, ExecuteEvents.selectHandler);\n    m_SelectionGuard = false;\n}\n```\n\n### 管理射线检测\n\n`EventSystem`中，还有一个非常重要的函数`RaycastAll()`，主要是获取目标。它被`PointerInputModule`类调用，大致来说是当鼠标设备可用或触摸板被使用时调用。\n\n```csharp\npublic void RaycastAll(PointerEventData eventData, List<RaycastResult> raycastResults)\n {\n     raycastResults.Clear();\n     //获取BaseRaycast对象\n     var modules = RaycasterManager.GetRaycasters();\n     var modulesCount = modules.Count;\n     for (int i = 0; i < modulesCount; ++i)\n     {\n         var module = modules[i];\n         if (module == null || !module.IsActive())\n             continue;\n        //调用Raycast方法，\n         module.Raycast(eventData, raycastResults);\n     }\n\n     raycastResults.Sort(s_RaycastComparer);\n }\n```\n\n它首先获取所有的`BaseRaycast`对象，然后调用它的`Raycast`方法，用以获取屏幕某个点下的所有目标（这个方法具体功能及实现的会在`Raycast`模块中进行讲解)，最后对得到的结果进行排序，大部分情况都是根据深度(`Depth`)进行排序，在一些情况下也会使用距离(`Distance`)、排序顺序(`SortingOrder`，如果是`UI`元素则是根据`Canvas`面板的`Sort order`值，`3D`物体默认是0)或者排序层级(`Sorting Layer`)等作为排序依据。\n\n讲了这么一大堆，来张图总结一下。**`EventSystem`会在`Update`中调用输入模块的`Process`方法来处理输入消息，`PointerInputModule`会调用`EventSystem`中的`RaycastAll`方法进行射线检测，`RaycastAll`又会调用`BastRaycaster`的`Raycast`方法执行具体的射线检测操作，主要是获取被选中的目标信息。**\n\n![](https://pic4.zhimg.com/80/v2-9685293899700c01f1d93245f0deda87_720w.jpg)\n\n简单概括一下`UML`图的含义，比如实线+三角形表示继承，实线+箭头表示关联，虚线+箭头表示依赖，关联和依赖的区别主要是引用其他类作为成员变量代表的是关联关系，将其他类作为局部变量、方法参数，或者引用它的静态方法，就属于依赖关系。\n\n### **`InputModules`**\n\n输入模块是配置和定制事件系统主逻辑的地方。 自带的输入模块有两个，一个是为独立输入(`StandaloneInputModule`)，另一个是为触摸输入(`TouchInputModule`)。 `StandaloneInputModule`是`PC`、`Mac&Linux`上的具体实现，而`TouchInputModule`是`IOS`、`Android`等移动平台上的具体实现，每个模块都按照给定配置接收和分派事件。 运行`EventSystem`后，它会查看附加了哪些输入模块，并将事件传递给特定的模块。 内置的输入模块旨在支持常见的游戏配置，如触摸输入、控制器输入、键盘输入和鼠标输入等。\n\n它的主要任务有三个，分别是\n\n* **处理输入**\n* **管理事件状态**\n* **发送事件到场景对象**\n\n在讲`Button`的时候我们提到鼠标的点击事件是在`BaseInputModule`中触发的，除此之外，`EventInterface`接口中的其他事件也都是由输入模块产生的，具体触发条件如下：\n\n* 当鼠标或触摸进入、退出当前对象时执行`pointerEnterHandler`、`pointerExitHandler`。\n* 在鼠标或者触摸按下、松开时执行`pointerDownHandler`、`pointerUpHandler`。\n* 在鼠标或触摸松开并且与按下时是同一个响应物体时执行`pointerClickHandler`。\n* 在鼠标或触摸位置发生偏移（偏移值大于一个很小的常量）时执行`beginDragHandler`。\n* 在鼠标或者触摸按下且当前对象可以响应拖拽事件时执行`initializePotentialDrag`。\n* 对象正在被拖拽且鼠标或触摸移动时执行`dragHandler`。\n* 对象正在被拖拽且鼠标或触摸松开时执行`endDragHandler`。\n* 鼠标或触摸松开且对象未响应`pointerClickHandler`情况下，如果对象正在被拖拽，执行`dropHandler`。\n* 当鼠标滚动差值大于零执行`scrollHandler`。\n* 当输入模块切换到`StandaloneInputModule`时执行`updateSelectedHandler`。（不需要Input类）\n* 当鼠标移动导致被选中的对象改变时，执行`selectHandler`和`deselectHandler`。\n* 导航事件可用情况下，按下上下左右键，执行`moveHandler`，按下确认键执行`submitHandler`，按下取消键执行`cancelHandler`。\n\n更加底层的调用还是`UnityEngine.Input`类，但可惜的是这部分`Unity`并没有开源。\n\n> 每次事件系统中只能有一个输入模块处于活跃状态，并且必须与`EventSystem`组件处于相同的游戏对象上。\n\n### 执行事件\n\n既然`InputModule`主要就是处理设备输入，发送事件到场景对象，那这些事件是怎么执行的呢？在讲`Button`的时候，我们提到过`ExecuteEvent`类，其实事件的执行都是通过这个类进行的，不过也需要`EventInterface`接口配合。这个类中定义了许多接口，比如鼠标按下、点击、拖拽等，下图展示了部分接口的继承关系。\n\n![](https://pic4.zhimg.com/80/v2-cfeebe5f05d3c8aa3dbe72fb99501913_720w.jpg)\n\n`ExecuteEvent`类中提供了一个方法让外部统一调用以执行事件\n\n```csharp\npublic static bool Execute<T>(GameObject target, BaseEventData eventData, EventFunction<T> functor) where T : IEventSystemHandler\n{\n    //从对象池中取出一个IEventSystemHandler类型的元素\n    var internalHandlers = s_HandlerListPool.Get();\n    //获取指定对象(target)的事件,并保存在internalHandlers中\n    GetEventList<T>(target, internalHandlers);\n    //  if (s_InternalHandlers.Count > 0)\n    //      Debug.Log(\"Executinng \" + typeof (T) + \" on \" + target);\n\n    var internalHandlersCount = internalHandlers.Count;\n    for (var i = 0; i < internalHandlersCount; i++)\n    {\n        T arg;\n        try\n        {\n            arg = (T)internalHandlers[i];\n        }\n        catch (Exception e)\n        {\n            var temp = internalHandlers[i];\n            Debug.LogException(new Exception(string.Format(\"Type {0} expected {1} received.\", typeof(T).Name, temp.GetType().Name), e));\n            continue;\n        }\n\n        try\n        {\n            //执行事件\n            functor(arg, eventData);\n        }\n        catch (Exception e)\n        {\n            Debug.LogException(e);\n        }\n    }\n\n    var handlerCount = internalHandlers.Count;\n    s_HandlerListPool.Release(internalHandlers);\n    return handlerCount > 0;\n}\n```\n\n这个方法之前有讲过，主要就是查找`target`对象上的`T`类型的组件列表，并遍历执行。\n\n除此之外，还有一个`GetEventHandler`方法，它主要是通过冒泡的方式查找到能够处理指定事件的对象。\n\n```csharp\n// 在游戏对象上冒泡指定的事件，找出哪个对象将实际接收事件。 \npublic static GameObject GetEventHandler<T>(GameObject root) where T : IEventSystemHandler\n{\n    if (root == null)\n        return null;\n\n    Transform t = root.transform;\n    //冒泡查找,如果物体本身不能处理输入的事件,交予parent处理\n    while (t != null)\n    {\n        if (CanHandleEvent<T>(t.gameObject))\n            return t.gameObject;\n        t = t.parent;\n    }\n  \n    return null;\n}\n\n // 指定的游戏对象是否能够处理指定的事件\n public static bool CanHandleEvent<T>(GameObject go) where T : IEventSystemHandler\n {\n     var internalHandlers = s_HandlerListPool.Get();\n     GetEventList<T>(go, internalHandlers);\n     var handlerCount = internalHandlers.Count;\n     s_HandlerListPool.Release(internalHandlers);\n     return handlerCount != 0;\n }\n```\n\n比如我们在场景中创建一个`Button`，那这个`Button`还包含了Text组件，当鼠标点击的时候会调用`GetEventHandler`函数，该函数的`root`参数其实是`Text`，但是会通过冒泡的方式查找到它的父物体`Button`，然后调用`Button`的点击事件。\n\n### **`Raycasters`**\n\n事件系统需要一个方法来检测当前输入事件需要发送到哪里，这是由`Raycasters`提供的。 给定一个屏幕空间位置，它们将收集所有潜在目标，找出它们是否在给定位置下，然后返回离屏幕最近的对象。 系统提供了以下几种类型的`Raycaster`:\n\n* **`Graphic Raycaster：` 检测`UI`元素**\n* **`Physics 2D Raycaster：` 用于`2D`物理元素**\n* **`Physics Raycaster：` 用于`3D`物理元素**\n\n![](https://pic3.zhimg.com/80/v2-bd2f8a5e377ab90e25e1d70392f418ee_720w.jpg)\n\n`BaseRaycaster`是其他`Raycaster`的基类，这是是一个抽象类。在它`OnEnable`里将自己注册到`RaycasterManager`，并在`OnDisable`的时候从后者移除。\n\n`RaycasterManager`是一个静态类，维护了一个`BaseRaycaster`类型的`List`，功能比较简单，包含获取(`Get`)、添加(`Add`)、移除(`Remove`)方法。\n\n`BaseRaycaster`中最重要的就是`Raycast`方法了，它的子类都对该方法进行了重写。\n\n### `Physics Raycaster`\n\n它主要用于检测`3D`物理元素，并且保存被射线检测到物体的数据，下面是部分代码\n\n```csharp\npublic override void Raycast(PointerEventData eventData, List<RaycastResult> resultAppendList)\n{\n    //判断是否超出摄像机的远近裁剪平面的距离\n    if (!ComputeRayAndDistance(eventData, ref ray, ref displayIndex, ref distanceToClipPlane))\n        return;\n\n    //采用ReflectionMethodsCache.Singleton.raycast3DAll()来获取所有射线照射到的对象\n    //用反射的方式把Physics.RaycastAll()方法缓存下来，让Unity的Physics模块与UI模块，保持低耦合，没有过分依赖。\n    if (m_MaxRayIntersections == 0)\n    {\n        m_Hits = ReflectionMethodsCache.Singleton.raycast3DAll(ray, distanceToClipPlane, finalEventMask);\n        hitCount = m_Hits.Length;\n    }\n    else\n    {\n        if (m_LastMaxRayIntersections != m_MaxRayIntersections)\n        {\n            m_Hits = new RaycastHit[m_MaxRayIntersections];\n            m_LastMaxRayIntersections = m_MaxRayIntersections;\n        }\n\n        hitCount = ReflectionMethodsCache.Singleton.getRaycastNonAlloc(ray, m_Hits, distanceToClipPlane, finalEventMask);\n    }\n\n    //获取到被射线照射到的对象，根据距离进行排序，然后包装成RaycastResult,加入到resultAppendList中\n    if (hitCount != 0)\n    {\n        if (hitCount > 1)\n            System.Array.Sort(m_Hits, 0, hitCount, RaycastHitComparer.instance);\n\n        for (int b = 0, bmax = hitCount; b < bmax; ++b)\n        {\n            var result = new RaycastResult\n            {\n                ...//为result赋值\n            };\n            resultAppendList.Add(result);\n        }\n    }\n}\n```\n\n`Physics2DRaycaster`继承自`PhysicsRaycaster`，实现功能和方式基本一致，只不过是用于检测`2D`物体，这里不具体讲解\n\n### `GraphicRaycast`\n\n**`GraphicRaycast`用于检测`UI`元素，它依赖于`Canvas`，我们在场景中添加`Canvas`默认都会包含一个`GraphicRaycast`组件。它先获取鼠标坐标，将其转换为`Camera`的视角坐标，然后分情况计算射线的距离（`hitDistance`），调用`Graphic`的`Raycast`方法来获取鼠标点下方的元素，最后将满足条件的结果添加到`resultAppendList`中。**\n\n![](https://pic4.zhimg.com/80/v2-8bd60abc5511daada3c336a9aee12193_720w.jpg)\n\n一大波代码来袭，不感兴趣可以跳过\n\n```csharp\npublic override void Raycast(PointerEventData eventData, List<RaycastResult> resultAppendList)\n{\n    if (canvas == null)\n        return;\n\n    //返回Canvas上的所有包含Graphic脚本并且raycastTarget=true的游戏物体\n    var canvasGraphics = GraphicRegistry.GetRaycastableGraphicsForCanvas(canvas);\n\n    if (canvasGraphics == null || canvasGraphics.Count == 0)\n        return;\n\n    int displayIndex;\n    //画布在ScreenSpaceOverlay模式下默认为null\n    var currentEventCamera = eventCamera; // Property can call Camera.main, so cache the reference\n\n    if (canvas.renderMode == RenderMode.ScreenSpaceOverlay || currentEventCamera == null)\n        displayIndex = canvas.targetDisplay;\n    else\n        displayIndex = currentEventCamera.targetDisplay;\n\n    //获取鼠标位置\n    var eventPosition = Display.RelativeMouseAt(eventData.position);\n    if (eventPosition != Vector3.zero)\n    {\n        int eventDisplayIndex = (int)eventPosition.z;\n      \n        if (eventDisplayIndex != displayIndex)\n            return;\n    }\n    else\n    {\n        eventPosition = eventData.position;\n    }\n\n    // Convert to view space\n    //将鼠标点在屏幕上的坐标转换成摄像机的视角坐标,如果超出范围则return\n    Vector2 pos;\n    if (currentEventCamera == null)\n    {\n        float w = Screen.width;\n        float h = Screen.height;\n        if (displayIndex > 0 && displayIndex < Display.displays.Length)\n        {\n            w = Display.displays[displayIndex].systemWidth;\n            h = Display.displays[displayIndex].systemHeight;\n        }\n        pos = new Vector2(eventPosition.x / w, eventPosition.y / h);\n    }\n    else\n        pos = currentEventCamera.ScreenToViewportPoint(eventPosition);\n\n    // If it's outside the camera's viewport, do nothing\n    if (pos.x < 0f || pos.x > 1f || pos.y < 0f || pos.y > 1f)\n        return;\n\n    float hitDistance = float.MaxValue;\n\n    Ray ray = new Ray();\n\n    //如果currentEventCamera不为空,摄像机发射射线\n    if (currentEventCamera != null)\n        ray = currentEventCamera.ScreenPointToRay(eventPosition);\n\n    //如果当前画布不是ScreenSpaceOverlay模式并且blockingObjects != BlockingObjects.None\n    //计算hitDistance的值\n    if (canvas.renderMode != RenderMode.ScreenSpaceOverlay && blockingObjects != BlockingObjects.None)\n    {\n        float distanceToClipPlane = 100.0f;\n\n        if (currentEventCamera != null)\n        {\n            float projectionDirection = ray.direction.z;\n            distanceToClipPlane = Mathf.Approximately(0.0f, projectionDirection)\n                ? Mathf.Infinity\n                : Mathf.Abs((currentEventCamera.farClipPlane - currentEventCamera.nearClipPlane) / projectionDirection);\n        }\n        #if PACKAGE_PHYSICS\n            if (blockingObjects == BlockingObjects.ThreeD || blockingObjects == BlockingObjects.All)\n            {\n                if (ReflectionMethodsCache.Singleton.raycast3D != null)\n                {\n                    var hits = ReflectionMethodsCache.Singleton.raycast3DAll(ray, distanceToClipPlane, (int)m_BlockingMask);\n                    if (hits.Length > 0)\n                        hitDistance = hits[0].distance;\n                }\n            }\n        #endif\n            #if PACKAGE_PHYSICS2D\n            if (blockingObjects == BlockingObjects.TwoD || blockingObjects == BlockingObjects.All)\n            {\n                if (ReflectionMethodsCache.Singleton.raycast2D != null)\n                {\n                    var hits = ReflectionMethodsCache.Singleton.getRayIntersectionAll(ray, distanceToClipPlane, (int)m_BlockingMask);\n                    if (hits.Length > 0)\n                        hitDistance = hits[0].distance;\n                }\n            }\n        #endif\n    }\n\n    m_RaycastResults.Clear();\n\n    //调用Raycast函数重载\n    Raycast(canvas, currentEventCamera, eventPosition, canvasGraphics, m_RaycastResults);\n\n    //遍历m_RaycastResults，判断Graphic的方向向量和Camera的方向向量是否相交，然后判断Graphic是否在Camera的前面，并且距离小于等于hitDistance，满足了这些条件，才会把它打包成RaycastResult添加到resultAppendList里。\n    int totalCount = m_RaycastResults.Count;\n    for (var index = 0; index < totalCount; index++)\n    {\n        var go = m_RaycastResults[index].gameObject;\n        bool appendGraphic = true;\n\n        if (ignoreReversedGraphics)\n        {\n            if (currentEventCamera == null)\n            {\n                // If we dont have a camera we know that we should always be facing forward\n                var dir = go.transform.rotation * Vector3.forward;\n                appendGraphic = Vector3.Dot(Vector3.forward, dir) > 0;\n            }\n            else\n            {\n                // If we have a camera compare the direction against the cameras forward.\n                var cameraForward = currentEventCamera.transform.rotation * Vector3.forward * currentEventCamera.nearClipPlane;\n                appendGraphic = Vector3.Dot(go.transform.position - currentEventCamera.transform.position - cameraForward, go.transform.forward) >= 0;\n            }\n        }\n\n        if (appendGraphic)\n        {\n            float distance = 0;\n            Transform trans = go.transform;\n            Vector3 transForward = trans.forward;\n\n            if (currentEventCamera == null || canvas.renderMode == RenderMode.ScreenSpaceOverlay)\n                distance = 0;\n            else\n            {\n                // http://geomalgorithms.com/a06-_intersect-2.html\n                distance = (Vector3.Dot(transForward, trans.position - ray.origin) / Vector3.Dot(transForward, ray.direction));\n\n                // Check to see if the go is behind the camera.\n                if (distance < 0)\n                    continue;\n            }\n\n            if (distance >= hitDistance)\n                continue;\n\n            var castResult = new RaycastResult\n            {\n                ......\n            };\n            resultAppendList.Add(castResult);\n        }\n    }\n```\n\n上述代码中调用了`Raycast`函数重载，作用是向屏幕投射射线并收集屏幕下方所有挂载了`Graphic`脚本的游戏对象，该函数内容为：\n\n```csharp\nprivate static void Raycast(Canvas canvas, Camera eventCamera, Vector2 pointerPosition, IList<Graphic> foundGraphics, List<Graphic> results)\n{\n    // Necessary for the event system\n    //遍历场景内Graphic对象(挂载Graphic脚本的对象)\n    int totalCount = foundGraphics.Count;\n    for (int i = 0; i < totalCount; ++i)\n    {\n        Graphic graphic = foundGraphics[i];\n\n        // -1 means it hasn't been processed by the canvas, which means it isn't actually drawn\n        if (!graphic.raycastTarget || graphic.canvasRenderer.cull || graphic.depth == -1)\n            continue;\n\n        //目标点是否在矩阵中\n        if (!RectTransformUtility.RectangleContainsScreenPoint(graphic.rectTransform, pointerPosition, eventCamera, graphic.raycastPadding))\n            continue;\n\n        //超出摄像机范围\n        if (eventCamera != null && eventCamera.WorldToScreenPoint(graphic.rectTransform.position).z > eventCamera.farClipPlane)\n            continue;\n\n        //调用符合条件的Graphic的Raycast方法\n        if (graphic.Raycast(pointerPosition, eventCamera))\n        {\n            s_SortedGraphics.Add(graphic);\n        }\n    }\n\n    s_SortedGraphics.Sort((g1, g2) => g2.depth.CompareTo(g1.depth));\n    totalCount = s_SortedGraphics.Count;\n    for (int i = 0; i < totalCount; ++i)\n        results.Add(s_SortedGraphics[i]);\n\n    s_SortedGraphics.Clear();\n}\n```\n\n **函数中又调用了`Graphic`类的`Raycast`函数，它主要是做两件事，一件是使用`RectTransform`的值过滤元素，另一件是使用`Raycast`函数确定射线击中的元素。** `RawImage`、`Image`和`Text`都间接继承自`Graphic`。\n\n![](https://pic2.zhimg.com/80/v2-b9be049e2a433d8a8437328d49e8dc4d_720w.jpg)\n\n```csharp\n public virtual bool Raycast(Vector2 sp, Camera eventCamera)\n {\n     if (!isActiveAndEnabled)\n         return false;\n\n     //UI元素,比如Image,Button等\n     var t = transform;\n\n     var components = ListPool<Component>.Get();\n\n     bool ignoreParentGroups = false;\n     bool continueTraversal = true;\n\n     while (t != null)\n     {\n         t.GetComponents(components);\n         for (var i = 0; i < components.Count; i++)\n         {\n\n             Debug.Log(components[i].name);\n             var canvas = components[i] as Canvas;\n             if (canvas != null && canvas.overrideSorting)\n                 continueTraversal = false;\n\n             //获取ICanvasRaycastFilter组件(Image,Mask,RectMask2D)\n             var filter = components[i] as ICanvasRaycastFilter;\n\n             if (filter == null)\n                 continue;\n\n             var raycastValid = true;\n\n             //判断sp点是否在有效的范围内\n             var group = components[i] as CanvasGroup;\n             if (group != null)\n             {\n                 if (ignoreParentGroups == false && group.ignoreParentGroups)\n                 {\n                     ignoreParentGroups = true;\n                     raycastValid = filter.IsRaycastLocationValid(sp, eventCamera);\n                 }\n                 else if (!ignoreParentGroups)\n                     raycastValid = filter.IsRaycastLocationValid(sp, eventCamera);\n             }\n             else\n             {\n                 raycastValid = filter.IsRaycastLocationValid(sp, eventCamera);\n             }\n\n             if (!raycastValid)\n             {\n                 ListPool<Component>.Release(components);\n                 return false;\n             }\n         }\n         //遍历它的父物体\n         t = continueTraversal ? t.parent : null;\n     }\n     ListPool<Component>.Release(components);\n     return true;\n }\n```\n\n这里也使用了`ICanvasRaycastFilter`接口中的`IsRaycastLocationValid`函数，主要还是判断点的位置是否有效，不过这里使用了Alpha测试。Image、Mask以及RectMask2D都继承了该接口。\n\n![](https://pic4.zhimg.com/80/v2-d80ee9c4b4f5c61ef1c05a1fc793bfab_720w.jpg)\n\n```csharp\n public virtual bool IsRaycastLocationValid(Vector2 screenPoint, Camera eventCamera)\n {\n     //小于阈值(alphaHitTestMinimumThreshold)的Alpha值将导致射线事件穿透图像。 \n     //值为1将导致只有完全不透明的像素在图像上注册相应射线事件。\n     if (alphaHitTestMinimumThreshold <= 0)\n         return true;\n\n     if (alphaHitTestMinimumThreshold > 1)\n         return false;\n\n     if (activeSprite == null)\n         return true;\n\n     Vector2 local;\n     if (!RectTransformUtility.ScreenPointToLocalPointInRectangle(rectTransform, screenPoint, eventCamera, out local))\n         return false;\n\n     Rect rect = GetPixelAdjustedRect();\n\n     // Convert to have lower left corner as reference point.\n     local.x += rectTransform.pivot.x * rect.width;\n     local.y += rectTransform.pivot.y * rect.height;\n\n     local = MapCoordinate(local, rect);\n\n     // Convert local coordinates to texture space.\n     Rect spriteRect = activeSprite.textureRect;\n     float x = (spriteRect.x + local.x) / activeSprite.texture.width;\n     float y = (spriteRect.y + local.y) / activeSprite.texture.height;\n\n     try\n     {\n         return activeSprite.texture.GetPixelBilinear(x, y).a >= alphaHitTestMinimumThreshold;\n     }\n     catch (UnityException e)\n     {\n         Debug.LogError(\"Using alphaHitTestMinimumThreshold greater than 0 on Image whose sprite texture cannot be read. \" + e.Message + \" Also make sure to disable sprite packing for this sprite.\", this);\n         return true;\n     }\n }\n```\n\n### `EventData`\n\n`EventData`用以存储事件信息，涉及到的东西不多，不展开讲解，层级关系如下图所示\n\n![](https://pic1.zhimg.com/80/v2-a72d1e210d9964fe63a440b4172d84ac_720w.jpg)\n\n## **实战：为Button的点击事件添加参数**\n\n在执行`Button`点击事件时，有些情况下我们需要获取触发事件的`Button`对象信息，这时可以自己实现一个`Button`点击事件\n\n```csharp\n/// <summary>\n/// UI事件监听器(与Button等UI挂在同一个物体上）：管理所有UGUI事件，提供事件参数类\n/// 若想看所有相关委托  自行查看EventTrigger类\n/// </summary>\npublic class UIEventListener : MonoBehaviour, IPointerClickHandler, IPointerDownHandler, IPointerUpHandler\n{\n    //2.定义委托\n    public delegate void PointerEventHandler(PointerEventData eventData);\n\n    //3.声明事件\n    public event PointerEventHandler PointerClick;\n    public event PointerEventHandler PointerDown;\n    public event PointerEventHandler PointerUp;\n\n    /// <summary>\n    /// 通过变换组件获取事件监听器\n    /// </summary>\n    /// <param name=\"transform\"></param>\n    /// <returns></returns>\n    public static UIEventListener GetEventListener(Transform transform)\n    {\n        UIEventListener uIEventListener = transform.GetComponent<UIEventListener>();\n\n        if (uIEventListener == null)\n            uIEventListener = transform.gameObject.AddComponent<UIEventListener>();\n\n        return uIEventListener;\n    }\n\n    //1.实现接口\n    public void OnPointerClick(PointerEventData eventData)\n    {\n        //表示抽象的有  抽象类  接口（多类抽象行为）  委托（一类抽象行为）\n        //4.引发事件\n        if (PointerClick != null)\n            PointerClick(eventData);\n    }\n\n    public void OnPointerDown(PointerEventData eventData)\n    {\n        PointerDown?.Invoke(eventData);\n    }\n\n    public void OnPointerUp(PointerEventData eventData)\n    {\n        PointerUp?.Invoke(eventData);\n    }\n}\n```\n\n使用的时候，我们只需要将它挂载到`Button`组件上，然后在`PointerClick`事件中添加自己的处理函数。\n\n## **总结**\n\n`Button`点击事件怎么触发的呢？首先是`EventSystem`在`Update`中调用当前输入模块的`Process`方法处理所有的鼠标事件，并且输入模块会调用`RaycastAll`来得到目标信息，通过冒泡的方式找到事件实际接收者并执行点击事件(这只是总体流程，中间省略很多具体步骤)。\n\n![](https://pic2.zhimg.com/80/v2-46b1ca8927625fb9ffb2cf94092b4651_720w.jpg)\n\n最后来一张层级关系图\n\n![](https://pic2.zhimg.com/80/v2-9a23d2a2f220e3e8100607ddc0999721_720w.jpg)","slug":"UGUI源码解析-1","published":1,"updated":"2022-03-15T15:12:00.564Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl0saopkd0001d0vhbodb1blz","content":"<h2 id=\"01-从Button开始解读UGUI源码\"><a href=\"#01-从Button开始解读UGUI源码\" class=\"headerlink\" title=\"01 | 从Button开始解读UGUI源码\"></a><strong>01 | 从<code>Button</code>开始解读<code>UGUI</code>源码</strong></h2><p>在Unity中，Button是我们最常用的组件之一了，它使用起来非常简单，例如监听一个Button点击事件</p>\n<figure class=\"highlight csharp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">GetComponent&lt;Button&gt;().onClick.AddListener(() =&gt; &#123; </span><br><span class=\"line\">    ...<span class=\"comment\">//按钮点击的处理逻辑</span></span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p>这样使用没有任何问题，但有时候我们会有疑问，为什么点击按钮<code>onClick</code>事件就会被触发呢？如何从回调函数中获取按钮的参数？让我们从源码中寻找答案。</p>\n<h2 id=\"查看源码前的配置\"><a href=\"#查看源码前的配置\" class=\"headerlink\" title=\"查看源码前的配置\"></a><strong>查看源码前的配置</strong></h2><p>为了能够方便的查阅源码以及进行代码调试，需要重新导入<code>UGUI</code>包。新建Unity项目，找到<code>Project/Packages/Unity UI</code>，右键 <code>Show in Explorer</code>，将其复制到任意一个新的文件夹中(记住保存的位置，待会需要引用)。</p>\n<p>接下来打开<code>Window/Package Manager</code></p>\n<p><img src=\"https://pic1.zhimg.com/80/v2-3ccfbcede96e7528a3b02780975fa198_720w.jpg\"></p>\n<p>找到<code>Unity UI</code>，将其<code>Remove</code></p>\n<p><img src=\"https://pic1.zhimg.com/80/v2-2f23bd59190b84d78c1249ac0ebde634_720w.jpg\"></p>\n<p>然后点击<code>“+”</code>号，选择<code>Add package form disk...</code>，找到之前保存的UI包，进入目录后选中<code>package.json</code>，点击打开。</p>\n<p><img src=\"https://pic1.zhimg.com/80/v2-63a9b186c1eaf811361227c1e2d752e0_720w.jpg\"></p>\n<p>大功告成，现在我们可以查看&#x2F;修改<code>UGUI</code>的源码了。</p>\n<h2 id=\"探究UGUI源码\"><a href=\"#探究UGUI源码\" class=\"headerlink\" title=\"探究UGUI源码\"></a><strong>探究<code>UGUI</code>源码</strong></h2><h3 id=\"Button的调用链\"><a href=\"#Button的调用链\" class=\"headerlink\" title=\"Button的调用链\"></a><strong><code>Button</code>的调用链</strong></h3><p>通过<code>F12</code>打开<code>Button</code>代码，容易发现它继承<code>Selectable</code>类，同时还继承了<code>IPointerClickHandler</code>、<code>ISubmitHandler</code>接口，这两个接口分别会在鼠标点击、点击提交按钮时调用它们的回调函数。</p>\n<figure class=\"highlight text\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> public class Button : Selectable, IPointerClickHandler, ISubmitHandler</span><br><span class=\"line\"> &#123;</span><br><span class=\"line\">     [Serializable]</span><br><span class=\"line\">     //定义一个点击事件</span><br><span class=\"line\">     public class ButtonClickedEvent : UnityEvent &#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">     // 实例化一个ButtonClickedEvent的事件</span><br><span class=\"line\">     [FormerlySerializedAs(&quot;onClick&quot;)]</span><br><span class=\"line\">     [SerializeField]</span><br><span class=\"line\">     private ButtonClickedEvent m_OnClick = new ButtonClickedEvent();</span><br><span class=\"line\"></span><br><span class=\"line\">     protected Button()</span><br><span class=\"line\">     &#123;&#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">     //常用的onClick.AddListener()就是监听这个事件</span><br><span class=\"line\">     public ButtonClickedEvent onClick</span><br><span class=\"line\">     &#123;</span><br><span class=\"line\">         get &#123; return m_OnClick; &#125;</span><br><span class=\"line\">         set &#123; m_OnClick = value; &#125;</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\">   </span><br><span class=\"line\">     //如果按钮处于活跃状态并且可交互(Interactable设置为true)，则触发事件</span><br><span class=\"line\">     private void Press()</span><br><span class=\"line\">     &#123;</span><br><span class=\"line\">         if (!IsActive() || !IsInteractable())</span><br><span class=\"line\">             return;</span><br><span class=\"line\"></span><br><span class=\"line\">         UISystemProfilerApi.AddMarker(&quot;Button.onClick&quot;, this);</span><br><span class=\"line\">         m_OnClick.Invoke();</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">     //鼠标点击时调用该函数，继承自 IPointerClickHandler 接口</span><br><span class=\"line\">     public virtual void OnPointerClick(PointerEventData eventData)</span><br><span class=\"line\">     &#123;</span><br><span class=\"line\">         if (eventData.button != PointerEventData.InputButton.Left)</span><br><span class=\"line\">             return;</span><br><span class=\"line\"></span><br><span class=\"line\">         Press();</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">     //按下“提交”键后触发(需要先选中该游戏物体)，继承自 ISubmitHandler</span><br><span class=\"line\">     //&quot;提交&quot;键可以在 Edit-&gt;Project Settings-&gt;Input-&gt;Submit 中自定义</span><br><span class=\"line\">     public virtual void OnSubmit(BaseEventData eventData)&#123;...&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">     private IEnumerator OnFinishSubmit()&#123;...&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><code>IPointerClickHandler</code>接口仅包含一个<code>OnPointerClick()</code>方法，当鼠标点击时会调用该接口的方法。而<code>Button</code>能触发点击事件是因为继承自<code>IPointerClickHandler</code>接口，并且重写了<code>OnPointerClick</code>方法。</p>\n<p>那<code>IPointerClickHandler</code>接口的方法又是被谁调用的呢？查找引用，发现是<code>ExecuteEvents</code>类的<code>Execute</code>方法(该类相当于事件执行器，提供了许多通用的事件处理方法)，并且<code>Execute</code>方法赋值给<code>s_PointerClickHandler</code>字段。</p>\n<figure class=\"highlight csharp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">readonly</span> EventFunction&lt;IPointerClickHandler&gt; s_PointerClickHandler = Execute;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">Execute</span>(<span class=\"params\">IPointerClickHandler handler, BaseEventData eventData</span>)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    handler.OnPointerClick(ValidateEventData&lt;PointerEventData&gt;(eventData));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p> <strong>为了能看的更清楚，总结一下调用关系，即<code>Button</code>继承自<code>Selectable</code>、<code>IPointercliClickHandler</code>、<code>ISubmitHandler</code>，而<code>IPointercliClickHandler</code>、<code>ISubmitHandler</code>继承自<code>IEventSystemHandler</code>，<code>ExecuteEvent</code>会在鼠标松开时通过<code>Execute</code>函数调用<code>IPointercliClickHandler</code>、<code>ISubmitHandler</code>接口的方法，从而触发<code>Button</code>的<code>onClick</code>事件</strong> ，如下图所示</p>\n<p><img src=\"https://pic3.zhimg.com/80/v2-1e8f7c467c473bd3b3315b3b6be8280a_720w.jpg\"></p>\n<p>继续往上找，<code>ExecuteEvents</code>类中还定义了一个<code>EventFunction&lt;T1&gt;</code>的泛型委托以及该委托类型的属性，这个返回<code>s_PointerClickHandler</code>，要查找谁触发的点击事件，只需要找到谁调用了<code>pointerClickHandler</code>即可</p>\n<figure class=\"highlight csharp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"built_in\">delegate</span> <span class=\"keyword\">void</span> <span class=\"title\">EventFunction</span>&lt;<span class=\"title\">T1</span>&gt;(<span class=\"params\">T1 handler, BaseEventData eventData</span>)</span>;</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> EventFunction&lt;IPointerClickHandler&gt; pointerClickHandler</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">get</span> &#123; <span class=\"keyword\">return</span> s_PointerClickHandler; &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>容易发现，<code>StandaloneInputModule</code>和<code>TouchInputModule</code>类对其有调用，这两个类继承自<code>BaseInput</code>，主要用以处理鼠标、键盘、控制器等设备的输入， <strong><code>EventSystem</code>类会在<code>Update</code>中每帧检查可用的输入模块的状态是否发生变化，并调用<code>TickModules()</code>和当前输入模块(<code>m_CurrentInputModule</code>)的<code>Process()</code>函数</strong> (后面会进行讲解)。下面是<code>StandaloneInputModule</code>的部分代码，它继承自<code>BaseInputModule</code></p>\n<figure class=\"highlight csharp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 计算和处理任何鼠标按钮状态的变化</span></span><br><span class=\"line\"><span class=\"comment\">//Process函数间接对其进行调用（调用链过长，不一一展示)</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">ProcessMousePress</span>(<span class=\"params\">MouseButtonEventData data</span>)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    ...<span class=\"comment\">//省略部分代码</span></span><br><span class=\"line\">       <span class=\"comment\">//鼠标按键抬起时调用（按键包括鼠标左键、中间滑轮和右键）</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (data.ReleasedThisFrame())</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        ReleaseMouse(pointerEvent, currentOverGo);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//满足松开鼠标的条件时调用</span></span><br><span class=\"line\"><span class=\"comment\">//currentOverGo ：当前选中的游戏物体</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">ReleaseMouse</span>(<span class=\"params\">PointerEventData pointerEvent, GameObject currentOverGo</span>)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    ...<span class=\"comment\">//省略部分代码</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (pointerEvent.pointerPress == pointerUpHandler &amp;&amp; pointerEvent.eligibleForClick)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"comment\">//执行Execute函数，传入ExecuteEvents.pointerClickHandler委托</span></span><br><span class=\"line\">        ExecuteEvents.Execute(pointerEvent.pointerPress, pointerEvent, ExecuteEvents.pointerClickHandler);</span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>查看<code>ExecuteEvents.Execute</code>的实现</p>\n<blockquote>\n<p>上面已经查看过<code>Execute</code>方法，为什么现在又出来一个？<br>因为<code>ExecuteEvents</code>中有N多个重载函数</p>\n</blockquote>\n<figure class=\"highlight csharp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//target ： 需要执行事件的游戏对象</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"built_in\">bool</span> <span class=\"title\">Execute</span>&lt;<span class=\"title\">T</span>&gt;(<span class=\"params\">GameObject target, BaseEventData eventData, EventFunction&lt;T&gt; functor</span>) <span class=\"keyword\">where</span> T : IEventSystemHandler</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> internalHandlers = s_HandlerListPool.Get();</span><br><span class=\"line\">    <span class=\"comment\">//获取target对象的事件</span></span><br><span class=\"line\">    GetEventList&lt;T&gt;(target, internalHandlers);</span><br><span class=\"line\">    <span class=\"comment\">//  if (s_InternalHandlers.Count &gt; 0)</span></span><br><span class=\"line\">    <span class=\"comment\">//      Debug.Log(&quot;Executinng &quot; + typeof (T) + &quot; on &quot; + target);</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &lt; internalHandlers.Count; i++)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        T arg;</span><br><span class=\"line\">        <span class=\"keyword\">try</span></span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            arg = (T)internalHandlers[i];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">catch</span> (Exception e)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">var</span> temp = internalHandlers[i];</span><br><span class=\"line\">            Debug.LogException(<span class=\"keyword\">new</span> Exception(<span class=\"built_in\">string</span>.Format(<span class=\"string\">&quot;Type &#123;0&#125; expected &#123;1&#125; received.&quot;</span>, <span class=\"keyword\">typeof</span>(T).Name, temp.GetType().Name), e));</span><br><span class=\"line\">            <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">try</span></span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"comment\">//执行EventFunction&lt;T&gt;委托,例如pointerClickHandler(arg,eventData)</span></span><br><span class=\"line\">            functor(arg, eventData);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">catch</span> (Exception e)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            Debug.LogException(e);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">var</span> handlerCount = internalHandlers.Count;</span><br><span class=\"line\">    s_HandlerListPool.Release(internalHandlers);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> handlerCount &gt; <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>也就是说，<code>EventSystem</code>会在<code>Update()</code>中调用当前可用<code>BaseInputModule</code>的<code>Process()</code>方法，该方法会处理鼠标的按下、抬起等事件，当鼠标抬起时调用<code>ReleaseMouse()</code>方法，并最终调用<code>Execute()</code>方法并触发<code>IPointerClick</code>事件。</strong> 如下图所示(为了简洁，类图并不完整)</p>\n<p><img src=\"https://pic2.zhimg.com/80/v2-271819772d80baa805565dc9182d3ab5_720w.jpg\"></p>\n<blockquote>\n<p>ReleaseMouse()是否只有鼠标左键抬起才会触发？<br>鼠标左、中、右键都会触发该函数，只不过<code>Button</code>在实现<code>OnPointerClick()</code>函数时忽略了鼠标中键和右键，使得只有左键能触发<code>Button</code>的点击事件</p>\n</blockquote>\n<p>但现在还存在一个问题，怎么知道上述代码中事件执行目标<code>target</code>的值呢？探究这个问题之前，我们需要先对<code>UGUI</code>源码有个总体的认识，因为它涉及的知识点比较多。</p>\n<h2 id=\"事件系统整体概述\"><a href=\"#事件系统整体概述\" class=\"headerlink\" title=\"事件系统整体概述\"></a><strong>事件系统整体概述</strong></h2><p>我们先看<code>EventSystem</code>源码在文件夹中的分类</p>\n<p><img src=\"https://pic4.zhimg.com/80/v2-15edd68d6268be3dd761ac92e6b6961b_720w.jpg\"></p>\n<p>从图中就可以看出主要 <strong>包含三个子板块，分别是<code>EvnetData</code>、<code>InputModules</code>和<code>Raycasters</code></strong> 。</p>\n<p>再看一个整体的类图，类图中包括了许多重要的类，如<code>EventSystem</code>、<code>BaseRaycast</code>、<code>BaseInputModule</code>等，它们都是继承自<code>UIBehaviour</code>，而<code>UIBehaviour</code>又是继承<code>MonoBehaviour</code>。（类图并不完整，只涉及部分类）</p>\n<p><img src=\"https://pic4.zhimg.com/80/v2-d401d582568a761d54f89a64a8371a93_720w.jpg\"></p>\n<p>接下来对这些内容进行详细讲解。</p>\n<h3 id=\"EventSystem类\"><a href=\"#EventSystem类\" class=\"headerlink\" title=\"EventSystem类\"></a><strong><code>EventSystem</code>类</strong></h3><p>事件系统主要是 <strong>基于输入(键盘、鼠标、触摸或自定义输入)向应用程序中的对象发送事件</strong> ，当然这需要其他组件的配合。当你在<code>GameObject</code>中添加<code>EventSystem</code>时，你会发现它并没有太多的功能，这是因为 <strong><code>EventSystem</code>本身被设计成事件系统不同模块之间通信的管理者和推动者</strong> ，它主要包含以下功能：</p>\n<ul>\n<li><strong>管理哪个游戏对象被认为是选中的</strong></li>\n<li><strong>管理正在使用的输入模块</strong></li>\n<li><strong>管理射线检测(如果需要)</strong></li>\n<li><strong>根据需要更新所有输入模块</strong></li>\n</ul>\n<h3 id=\"管理输入模块\"><a href=\"#管理输入模块\" class=\"headerlink\" title=\"管理输入模块\"></a>管理输入模块</h3><p>下面看一下具体代码。首先是声明了<code>BaseInputModule</code>类型的<code>List</code>和变量，用来保存输入模块(<code>Module</code>)</p>\n<figure class=\"highlight csharp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//系统输入模块</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> List&lt;BaseInputModule&gt; m_SystemInputModules = <span class=\"keyword\">new</span> List&lt;BaseInputModule&gt;();</span><br><span class=\"line\"><span class=\"comment\">//当前输入模块</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> BaseInputModule m_CurrentInputModule;</span><br></pre></td></tr></table></figure>\n\n<p>接下来，它会在<code>Update</code>中处理这些模块，调用<code>TickModules</code>方法，更新每一个模块，并且会在满足条件的情况下调用当前模块的<code>Process</code>方法</p>\n<figure class=\"highlight csharp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">virtual</span> <span class=\"keyword\">void</span> <span class=\"title\">Update</span>()</span></span><br><span class=\"line\"> &#123;</span><br><span class=\"line\">    <span class=\"comment\">//遍历m_SystemInputModules，如果其中的Module不为null，则调用UpdateModule方法</span></span><br><span class=\"line\">     TickModules();</span><br><span class=\"line\"></span><br><span class=\"line\">     <span class=\"comment\">//遍历m_SystemInputModules判断其中的输入模块是否支持当前平台</span></span><br><span class=\"line\">     <span class=\"comment\">//如果支持并且可以激活，则将其赋值给当前输入模块并Break</span></span><br><span class=\"line\">     <span class=\"built_in\">bool</span> changedModule = <span class=\"literal\">false</span>;</span><br><span class=\"line\">     <span class=\"keyword\">var</span> systemInputModulesCount = m_SystemInputModules.Count;</span><br><span class=\"line\">     <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &lt; systemInputModulesCount; i++)</span><br><span class=\"line\">     &#123;</span><br><span class=\"line\">         <span class=\"keyword\">var</span> module = m_SystemInputModules[i];</span><br><span class=\"line\">         <span class=\"keyword\">if</span> (module.IsModuleSupported() &amp;&amp; module.ShouldActivateModule())</span><br><span class=\"line\">         &#123;</span><br><span class=\"line\">             <span class=\"keyword\">if</span> (m_CurrentInputModule != module)</span><br><span class=\"line\">             &#123;</span><br><span class=\"line\">                 ChangeEventModule(module);</span><br><span class=\"line\">                 changedModule = <span class=\"literal\">true</span>;</span><br><span class=\"line\">             &#125;</span><br><span class=\"line\">             <span class=\"keyword\">break</span>;</span><br><span class=\"line\">         &#125;</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">     <span class=\"comment\">//如果上面没找到符合条件的模块，则使用第一个支持当前平台的模块</span></span><br><span class=\"line\">     <span class=\"keyword\">if</span> (m_CurrentInputModule == <span class=\"literal\">null</span>)</span><br><span class=\"line\">     &#123;</span><br><span class=\"line\">         <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &lt; systemInputModulesCount; i++)</span><br><span class=\"line\">         &#123;</span><br><span class=\"line\">             <span class=\"keyword\">var</span> module = m_SystemInputModules[i];</span><br><span class=\"line\">             <span class=\"keyword\">if</span> (module.IsModuleSupported())</span><br><span class=\"line\">             &#123;</span><br><span class=\"line\">                 ChangeEventModule(module);</span><br><span class=\"line\">                 changedModule = <span class=\"literal\">true</span>;</span><br><span class=\"line\">                 <span class=\"keyword\">break</span>;</span><br><span class=\"line\">             &#125;</span><br><span class=\"line\">         &#125;</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">     <span class=\"comment\">//如果当前模块没有发生变化并且当前模块不为空</span></span><br><span class=\"line\">     <span class=\"keyword\">if</span> (!changedModule &amp;&amp; m_CurrentInputModule != <span class=\"literal\">null</span>)</span><br><span class=\"line\">         m_CurrentInputModule.Process();</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">TickModules</span>()</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> systemInputModulesCount = m_SystemInputModules.Count;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &lt; systemInputModulesCount; i++)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (m_SystemInputModules[i] != <span class=\"literal\">null</span>)</span><br><span class=\"line\">            m_SystemInputModules[i].UpdateModule();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><code>Process()</code>方法主要是将各种输入事件（如点击、拖拽等事件）传递给<code>EventSystem</code>当前选中的<code>GameObject</code>(即<code>m_CurrentSelected</code>)</p>\n<h3 id=\"管理选中的游戏对象\"><a href=\"#管理选中的游戏对象\" class=\"headerlink\" title=\"管理选中的游戏对象\"></a>管理选中的游戏对象</h3><p>当场景中的游戏物体(<code>Button</code>、<code>Dropdown</code>、<code>InputField</code>等)被选中时，会通知之前选中的对象执行被取消(<code>OnDeselect</code>)事件，通知当前选中的对象执行选中(<code>OnSelect</code>)事件，部分代码如下</p>\n<figure class=\"highlight csharp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">SetSelectedGameObject</span>(<span class=\"params\">GameObject selected, BaseEventData pointer</span>)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    ......<span class=\"comment\">//省略部分代码</span></span><br><span class=\"line\">    <span class=\"comment\">//通知之前被选中取消选中</span></span><br><span class=\"line\">    ExecuteEvents.Execute(m_CurrentSelected, pointer, ExecuteEvents.deselectHandler);</span><br><span class=\"line\">    m_CurrentSelected = selected;</span><br><span class=\"line\">    <span class=\"comment\">//通知当前物体被选中</span></span><br><span class=\"line\">    ExecuteEvents.Execute(m_CurrentSelected, pointer, ExecuteEvents.selectHandler);</span><br><span class=\"line\">    m_SelectionGuard = <span class=\"literal\">false</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"管理射线检测\"><a href=\"#管理射线检测\" class=\"headerlink\" title=\"管理射线检测\"></a>管理射线检测</h3><p><code>EventSystem</code>中，还有一个非常重要的函数<code>RaycastAll()</code>，主要是获取目标。它被<code>PointerInputModule</code>类调用，大致来说是当鼠标设备可用或触摸板被使用时调用。</p>\n<figure class=\"highlight csharp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">RaycastAll</span>(<span class=\"params\">PointerEventData eventData, List&lt;RaycastResult&gt; raycastResults</span>)</span></span><br><span class=\"line\"> &#123;</span><br><span class=\"line\">     raycastResults.Clear();</span><br><span class=\"line\">     <span class=\"comment\">//获取BaseRaycast对象</span></span><br><span class=\"line\">     <span class=\"keyword\">var</span> modules = RaycasterManager.GetRaycasters();</span><br><span class=\"line\">     <span class=\"keyword\">var</span> modulesCount = modules.Count;</span><br><span class=\"line\">     <span class=\"keyword\">for</span> (<span class=\"built_in\">int</span> i = <span class=\"number\">0</span>; i &lt; modulesCount; ++i)</span><br><span class=\"line\">     &#123;</span><br><span class=\"line\">         <span class=\"keyword\">var</span> module = modules[i];</span><br><span class=\"line\">         <span class=\"keyword\">if</span> (module == <span class=\"literal\">null</span> || !module.IsActive())</span><br><span class=\"line\">             <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">        <span class=\"comment\">//调用Raycast方法，</span></span><br><span class=\"line\">         module.Raycast(eventData, raycastResults);</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">     raycastResults.Sort(s_RaycastComparer);</span><br><span class=\"line\"> &#125;</span><br></pre></td></tr></table></figure>\n\n<p>它首先获取所有的<code>BaseRaycast</code>对象，然后调用它的<code>Raycast</code>方法，用以获取屏幕某个点下的所有目标（这个方法具体功能及实现的会在<code>Raycast</code>模块中进行讲解)，最后对得到的结果进行排序，大部分情况都是根据深度(<code>Depth</code>)进行排序，在一些情况下也会使用距离(<code>Distance</code>)、排序顺序(<code>SortingOrder</code>，如果是<code>UI</code>元素则是根据<code>Canvas</code>面板的<code>Sort order</code>值，<code>3D</code>物体默认是0)或者排序层级(<code>Sorting Layer</code>)等作为排序依据。</p>\n<p>讲了这么一大堆，来张图总结一下。**<code>EventSystem</code>会在<code>Update</code>中调用输入模块的<code>Process</code>方法来处理输入消息，<code>PointerInputModule</code>会调用<code>EventSystem</code>中的<code>RaycastAll</code>方法进行射线检测，<code>RaycastAll</code>又会调用<code>BastRaycaster</code>的<code>Raycast</code>方法执行具体的射线检测操作，主要是获取被选中的目标信息。**</p>\n<p><img src=\"https://pic4.zhimg.com/80/v2-9685293899700c01f1d93245f0deda87_720w.jpg\"></p>\n<p>简单概括一下<code>UML</code>图的含义，比如实线+三角形表示继承，实线+箭头表示关联，虚线+箭头表示依赖，关联和依赖的区别主要是引用其他类作为成员变量代表的是关联关系，将其他类作为局部变量、方法参数，或者引用它的静态方法，就属于依赖关系。</p>\n<h3 id=\"InputModules\"><a href=\"#InputModules\" class=\"headerlink\" title=\"InputModules\"></a><strong><code>InputModules</code></strong></h3><p>输入模块是配置和定制事件系统主逻辑的地方。 自带的输入模块有两个，一个是为独立输入(<code>StandaloneInputModule</code>)，另一个是为触摸输入(<code>TouchInputModule</code>)。 <code>StandaloneInputModule</code>是<code>PC</code>、<code>Mac&amp;Linux</code>上的具体实现，而<code>TouchInputModule</code>是<code>IOS</code>、<code>Android</code>等移动平台上的具体实现，每个模块都按照给定配置接收和分派事件。 运行<code>EventSystem</code>后，它会查看附加了哪些输入模块，并将事件传递给特定的模块。 内置的输入模块旨在支持常见的游戏配置，如触摸输入、控制器输入、键盘输入和鼠标输入等。</p>\n<p>它的主要任务有三个，分别是</p>\n<ul>\n<li><strong>处理输入</strong></li>\n<li><strong>管理事件状态</strong></li>\n<li><strong>发送事件到场景对象</strong></li>\n</ul>\n<p>在讲<code>Button</code>的时候我们提到鼠标的点击事件是在<code>BaseInputModule</code>中触发的，除此之外，<code>EventInterface</code>接口中的其他事件也都是由输入模块产生的，具体触发条件如下：</p>\n<ul>\n<li>当鼠标或触摸进入、退出当前对象时执行<code>pointerEnterHandler</code>、<code>pointerExitHandler</code>。</li>\n<li>在鼠标或者触摸按下、松开时执行<code>pointerDownHandler</code>、<code>pointerUpHandler</code>。</li>\n<li>在鼠标或触摸松开并且与按下时是同一个响应物体时执行<code>pointerClickHandler</code>。</li>\n<li>在鼠标或触摸位置发生偏移（偏移值大于一个很小的常量）时执行<code>beginDragHandler</code>。</li>\n<li>在鼠标或者触摸按下且当前对象可以响应拖拽事件时执行<code>initializePotentialDrag</code>。</li>\n<li>对象正在被拖拽且鼠标或触摸移动时执行<code>dragHandler</code>。</li>\n<li>对象正在被拖拽且鼠标或触摸松开时执行<code>endDragHandler</code>。</li>\n<li>鼠标或触摸松开且对象未响应<code>pointerClickHandler</code>情况下，如果对象正在被拖拽，执行<code>dropHandler</code>。</li>\n<li>当鼠标滚动差值大于零执行<code>scrollHandler</code>。</li>\n<li>当输入模块切换到<code>StandaloneInputModule</code>时执行<code>updateSelectedHandler</code>。（不需要Input类）</li>\n<li>当鼠标移动导致被选中的对象改变时，执行<code>selectHandler</code>和<code>deselectHandler</code>。</li>\n<li>导航事件可用情况下，按下上下左右键，执行<code>moveHandler</code>，按下确认键执行<code>submitHandler</code>，按下取消键执行<code>cancelHandler</code>。</li>\n</ul>\n<p>更加底层的调用还是<code>UnityEngine.Input</code>类，但可惜的是这部分<code>Unity</code>并没有开源。</p>\n<blockquote>\n<p>每次事件系统中只能有一个输入模块处于活跃状态，并且必须与<code>EventSystem</code>组件处于相同的游戏对象上。</p>\n</blockquote>\n<h3 id=\"执行事件\"><a href=\"#执行事件\" class=\"headerlink\" title=\"执行事件\"></a>执行事件</h3><p>既然<code>InputModule</code>主要就是处理设备输入，发送事件到场景对象，那这些事件是怎么执行的呢？在讲<code>Button</code>的时候，我们提到过<code>ExecuteEvent</code>类，其实事件的执行都是通过这个类进行的，不过也需要<code>EventInterface</code>接口配合。这个类中定义了许多接口，比如鼠标按下、点击、拖拽等，下图展示了部分接口的继承关系。</p>\n<p><img src=\"https://pic4.zhimg.com/80/v2-cfeebe5f05d3c8aa3dbe72fb99501913_720w.jpg\"></p>\n<p><code>ExecuteEvent</code>类中提供了一个方法让外部统一调用以执行事件</p>\n<figure class=\"highlight csharp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"built_in\">bool</span> <span class=\"title\">Execute</span>&lt;<span class=\"title\">T</span>&gt;(<span class=\"params\">GameObject target, BaseEventData eventData, EventFunction&lt;T&gt; functor</span>) <span class=\"keyword\">where</span> T : IEventSystemHandler</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"comment\">//从对象池中取出一个IEventSystemHandler类型的元素</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> internalHandlers = s_HandlerListPool.Get();</span><br><span class=\"line\">    <span class=\"comment\">//获取指定对象(target)的事件,并保存在internalHandlers中</span></span><br><span class=\"line\">    GetEventList&lt;T&gt;(target, internalHandlers);</span><br><span class=\"line\">    <span class=\"comment\">//  if (s_InternalHandlers.Count &gt; 0)</span></span><br><span class=\"line\">    <span class=\"comment\">//      Debug.Log(&quot;Executinng &quot; + typeof (T) + &quot; on &quot; + target);</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">var</span> internalHandlersCount = internalHandlers.Count;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &lt; internalHandlersCount; i++)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        T arg;</span><br><span class=\"line\">        <span class=\"keyword\">try</span></span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            arg = (T)internalHandlers[i];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">catch</span> (Exception e)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">var</span> temp = internalHandlers[i];</span><br><span class=\"line\">            Debug.LogException(<span class=\"keyword\">new</span> Exception(<span class=\"built_in\">string</span>.Format(<span class=\"string\">&quot;Type &#123;0&#125; expected &#123;1&#125; received.&quot;</span>, <span class=\"keyword\">typeof</span>(T).Name, temp.GetType().Name), e));</span><br><span class=\"line\">            <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">try</span></span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"comment\">//执行事件</span></span><br><span class=\"line\">            functor(arg, eventData);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">catch</span> (Exception e)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            Debug.LogException(e);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">var</span> handlerCount = internalHandlers.Count;</span><br><span class=\"line\">    s_HandlerListPool.Release(internalHandlers);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> handlerCount &gt; <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这个方法之前有讲过，主要就是查找<code>target</code>对象上的<code>T</code>类型的组件列表，并遍历执行。</p>\n<p>除此之外，还有一个<code>GetEventHandler</code>方法，它主要是通过冒泡的方式查找到能够处理指定事件的对象。</p>\n<figure class=\"highlight csharp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 在游戏对象上冒泡指定的事件，找出哪个对象将实际接收事件。 </span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> GameObject <span class=\"title\">GetEventHandler</span>&lt;<span class=\"title\">T</span>&gt;(<span class=\"params\">GameObject root</span>) <span class=\"keyword\">where</span> T : IEventSystemHandler</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (root == <span class=\"literal\">null</span>)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    Transform t = root.transform;</span><br><span class=\"line\">    <span class=\"comment\">//冒泡查找,如果物体本身不能处理输入的事件,交予parent处理</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (t != <span class=\"literal\">null</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (CanHandleEvent&lt;T&gt;(t.gameObject))</span><br><span class=\"line\">            <span class=\"keyword\">return</span> t.gameObject;</span><br><span class=\"line\">        t = t.parent;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"> <span class=\"comment\">// 指定的游戏对象是否能够处理指定的事件</span></span><br><span class=\"line\"> <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"built_in\">bool</span> <span class=\"title\">CanHandleEvent</span>&lt;<span class=\"title\">T</span>&gt;(<span class=\"params\">GameObject go</span>) <span class=\"keyword\">where</span> T : IEventSystemHandler</span></span><br><span class=\"line\"> &#123;</span><br><span class=\"line\">     <span class=\"keyword\">var</span> internalHandlers = s_HandlerListPool.Get();</span><br><span class=\"line\">     GetEventList&lt;T&gt;(go, internalHandlers);</span><br><span class=\"line\">     <span class=\"keyword\">var</span> handlerCount = internalHandlers.Count;</span><br><span class=\"line\">     s_HandlerListPool.Release(internalHandlers);</span><br><span class=\"line\">     <span class=\"keyword\">return</span> handlerCount != <span class=\"number\">0</span>;</span><br><span class=\"line\"> &#125;</span><br></pre></td></tr></table></figure>\n\n<p>比如我们在场景中创建一个<code>Button</code>，那这个<code>Button</code>还包含了Text组件，当鼠标点击的时候会调用<code>GetEventHandler</code>函数，该函数的<code>root</code>参数其实是<code>Text</code>，但是会通过冒泡的方式查找到它的父物体<code>Button</code>，然后调用<code>Button</code>的点击事件。</p>\n<h3 id=\"Raycasters\"><a href=\"#Raycasters\" class=\"headerlink\" title=\"Raycasters\"></a><strong><code>Raycasters</code></strong></h3><p>事件系统需要一个方法来检测当前输入事件需要发送到哪里，这是由<code>Raycasters</code>提供的。 给定一个屏幕空间位置，它们将收集所有潜在目标，找出它们是否在给定位置下，然后返回离屏幕最近的对象。 系统提供了以下几种类型的<code>Raycaster</code>:</p>\n<ul>\n<li><strong><code>Graphic Raycaster：</code> 检测<code>UI</code>元素</strong></li>\n<li><strong><code>Physics 2D Raycaster：</code> 用于<code>2D</code>物理元素</strong></li>\n<li><strong><code>Physics Raycaster：</code> 用于<code>3D</code>物理元素</strong></li>\n</ul>\n<p><img src=\"https://pic3.zhimg.com/80/v2-bd2f8a5e377ab90e25e1d70392f418ee_720w.jpg\"></p>\n<p><code>BaseRaycaster</code>是其他<code>Raycaster</code>的基类，这是是一个抽象类。在它<code>OnEnable</code>里将自己注册到<code>RaycasterManager</code>，并在<code>OnDisable</code>的时候从后者移除。</p>\n<p><code>RaycasterManager</code>是一个静态类，维护了一个<code>BaseRaycaster</code>类型的<code>List</code>，功能比较简单，包含获取(<code>Get</code>)、添加(<code>Add</code>)、移除(<code>Remove</code>)方法。</p>\n<p><code>BaseRaycaster</code>中最重要的就是<code>Raycast</code>方法了，它的子类都对该方法进行了重写。</p>\n<h3 id=\"Physics-Raycaster\"><a href=\"#Physics-Raycaster\" class=\"headerlink\" title=\"Physics Raycaster\"></a><code>Physics Raycaster</code></h3><p>它主要用于检测<code>3D</code>物理元素，并且保存被射线检测到物体的数据，下面是部分代码</p>\n<figure class=\"highlight csharp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">override</span> <span class=\"keyword\">void</span> <span class=\"title\">Raycast</span>(<span class=\"params\">PointerEventData eventData, List&lt;RaycastResult&gt; resultAppendList</span>)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"comment\">//判断是否超出摄像机的远近裁剪平面的距离</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!ComputeRayAndDistance(eventData, <span class=\"keyword\">ref</span> ray, <span class=\"keyword\">ref</span> displayIndex, <span class=\"keyword\">ref</span> distanceToClipPlane))</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//采用ReflectionMethodsCache.Singleton.raycast3DAll()来获取所有射线照射到的对象</span></span><br><span class=\"line\">    <span class=\"comment\">//用反射的方式把Physics.RaycastAll()方法缓存下来，让Unity的Physics模块与UI模块，保持低耦合，没有过分依赖。</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (m_MaxRayIntersections == <span class=\"number\">0</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        m_Hits = ReflectionMethodsCache.Singleton.raycast3DAll(ray, distanceToClipPlane, finalEventMask);</span><br><span class=\"line\">        hitCount = m_Hits.Length;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">else</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (m_LastMaxRayIntersections != m_MaxRayIntersections)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            m_Hits = <span class=\"keyword\">new</span> RaycastHit[m_MaxRayIntersections];</span><br><span class=\"line\">            m_LastMaxRayIntersections = m_MaxRayIntersections;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        hitCount = ReflectionMethodsCache.Singleton.getRaycastNonAlloc(ray, m_Hits, distanceToClipPlane, finalEventMask);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//获取到被射线照射到的对象，根据距离进行排序，然后包装成RaycastResult,加入到resultAppendList中</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (hitCount != <span class=\"number\">0</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (hitCount &gt; <span class=\"number\">1</span>)</span><br><span class=\"line\">            System.Array.Sort(m_Hits, <span class=\"number\">0</span>, hitCount, RaycastHitComparer.instance);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"built_in\">int</span> b = <span class=\"number\">0</span>, bmax = hitCount; b &lt; bmax; ++b)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">var</span> result = <span class=\"keyword\">new</span> RaycastResult</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                ...<span class=\"comment\">//为result赋值</span></span><br><span class=\"line\">            &#125;;</span><br><span class=\"line\">            resultAppendList.Add(result);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><code>Physics2DRaycaster</code>继承自<code>PhysicsRaycaster</code>，实现功能和方式基本一致，只不过是用于检测<code>2D</code>物体，这里不具体讲解</p>\n<h3 id=\"GraphicRaycast\"><a href=\"#GraphicRaycast\" class=\"headerlink\" title=\"GraphicRaycast\"></a><code>GraphicRaycast</code></h3><p><strong><code>GraphicRaycast</code>用于检测<code>UI</code>元素，它依赖于<code>Canvas</code>，我们在场景中添加<code>Canvas</code>默认都会包含一个<code>GraphicRaycast</code>组件。它先获取鼠标坐标，将其转换为<code>Camera</code>的视角坐标，然后分情况计算射线的距离（<code>hitDistance</code>），调用<code>Graphic</code>的<code>Raycast</code>方法来获取鼠标点下方的元素，最后将满足条件的结果添加到<code>resultAppendList</code>中。</strong></p>\n<p><img src=\"https://pic4.zhimg.com/80/v2-8bd60abc5511daada3c336a9aee12193_720w.jpg\"></p>\n<p>一大波代码来袭，不感兴趣可以跳过</p>\n<figure class=\"highlight csharp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br><span class=\"line\">147</span><br><span class=\"line\">148</span><br><span class=\"line\">149</span><br><span class=\"line\">150</span><br><span class=\"line\">151</span><br><span class=\"line\">152</span><br><span class=\"line\">153</span><br><span class=\"line\">154</span><br><span class=\"line\">155</span><br><span class=\"line\">156</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">override</span> <span class=\"keyword\">void</span> <span class=\"title\">Raycast</span>(<span class=\"params\">PointerEventData eventData, List&lt;RaycastResult&gt; resultAppendList</span>)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (canvas == <span class=\"literal\">null</span>)</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//返回Canvas上的所有包含Graphic脚本并且raycastTarget=true的游戏物体</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> canvasGraphics = GraphicRegistry.GetRaycastableGraphicsForCanvas(canvas);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (canvasGraphics == <span class=\"literal\">null</span> || canvasGraphics.Count == <span class=\"number\">0</span>)</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">int</span> displayIndex;</span><br><span class=\"line\">    <span class=\"comment\">//画布在ScreenSpaceOverlay模式下默认为null</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> currentEventCamera = eventCamera; <span class=\"comment\">// Property can call Camera.main, so cache the reference</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (canvas.renderMode == RenderMode.ScreenSpaceOverlay || currentEventCamera == <span class=\"literal\">null</span>)</span><br><span class=\"line\">        displayIndex = canvas.targetDisplay;</span><br><span class=\"line\">    <span class=\"keyword\">else</span></span><br><span class=\"line\">        displayIndex = currentEventCamera.targetDisplay;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//获取鼠标位置</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> eventPosition = Display.RelativeMouseAt(eventData.position);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (eventPosition != Vector3.zero)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"built_in\">int</span> eventDisplayIndex = (<span class=\"built_in\">int</span>)eventPosition.z;</span><br><span class=\"line\">      </span><br><span class=\"line\">        <span class=\"keyword\">if</span> (eventDisplayIndex != displayIndex)</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">else</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        eventPosition = eventData.position;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Convert to view space</span></span><br><span class=\"line\">    <span class=\"comment\">//将鼠标点在屏幕上的坐标转换成摄像机的视角坐标,如果超出范围则return</span></span><br><span class=\"line\">    Vector2 pos;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (currentEventCamera == <span class=\"literal\">null</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"built_in\">float</span> w = Screen.width;</span><br><span class=\"line\">        <span class=\"built_in\">float</span> h = Screen.height;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (displayIndex &gt; <span class=\"number\">0</span> &amp;&amp; displayIndex &lt; Display.displays.Length)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            w = Display.displays[displayIndex].systemWidth;</span><br><span class=\"line\">            h = Display.displays[displayIndex].systemHeight;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        pos = <span class=\"keyword\">new</span> Vector2(eventPosition.x / w, eventPosition.y / h);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">else</span></span><br><span class=\"line\">        pos = currentEventCamera.ScreenToViewportPoint(eventPosition);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// If it&#x27;s outside the camera&#x27;s viewport, do nothing</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (pos.x &lt; <span class=\"number\">0f</span> || pos.x &gt; <span class=\"number\">1f</span> || pos.y &lt; <span class=\"number\">0f</span> || pos.y &gt; <span class=\"number\">1f</span>)</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">float</span> hitDistance = <span class=\"built_in\">float</span>.MaxValue;</span><br><span class=\"line\"></span><br><span class=\"line\">    Ray ray = <span class=\"keyword\">new</span> Ray();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//如果currentEventCamera不为空,摄像机发射射线</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (currentEventCamera != <span class=\"literal\">null</span>)</span><br><span class=\"line\">        ray = currentEventCamera.ScreenPointToRay(eventPosition);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//如果当前画布不是ScreenSpaceOverlay模式并且blockingObjects != BlockingObjects.None</span></span><br><span class=\"line\">    <span class=\"comment\">//计算hitDistance的值</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (canvas.renderMode != RenderMode.ScreenSpaceOverlay &amp;&amp; blockingObjects != BlockingObjects.None)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"built_in\">float</span> distanceToClipPlane = <span class=\"number\">100.0f</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (currentEventCamera != <span class=\"literal\">null</span>)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"built_in\">float</span> projectionDirection = ray.direction.z;</span><br><span class=\"line\">            distanceToClipPlane = Mathf.Approximately(<span class=\"number\">0.0f</span>, projectionDirection)</span><br><span class=\"line\">                ? Mathf.Infinity</span><br><span class=\"line\">                : Mathf.Abs((currentEventCamera.farClipPlane - currentEventCamera.nearClipPlane) / projectionDirection);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"meta\">#<span class=\"keyword\">if</span> PACKAGE_PHYSICS</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (blockingObjects == BlockingObjects.ThreeD || blockingObjects == BlockingObjects.All)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (ReflectionMethodsCache.Singleton.raycast3D != <span class=\"literal\">null</span>)</span><br><span class=\"line\">                &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">var</span> hits = ReflectionMethodsCache.Singleton.raycast3DAll(ray, distanceToClipPlane, (<span class=\"built_in\">int</span>)m_BlockingMask);</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (hits.Length &gt; <span class=\"number\">0</span>)</span><br><span class=\"line\">                        hitDistance = hits[<span class=\"number\">0</span>].distance;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        <span class=\"meta\">#<span class=\"keyword\">endif</span></span></span><br><span class=\"line\">            <span class=\"meta\">#<span class=\"keyword\">if</span> PACKAGE_PHYSICS2D</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (blockingObjects == BlockingObjects.TwoD || blockingObjects == BlockingObjects.All)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (ReflectionMethodsCache.Singleton.raycast2D != <span class=\"literal\">null</span>)</span><br><span class=\"line\">                &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">var</span> hits = ReflectionMethodsCache.Singleton.getRayIntersectionAll(ray, distanceToClipPlane, (<span class=\"built_in\">int</span>)m_BlockingMask);</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (hits.Length &gt; <span class=\"number\">0</span>)</span><br><span class=\"line\">                        hitDistance = hits[<span class=\"number\">0</span>].distance;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        <span class=\"meta\">#<span class=\"keyword\">endif</span></span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    m_RaycastResults.Clear();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//调用Raycast函数重载</span></span><br><span class=\"line\">    Raycast(canvas, currentEventCamera, eventPosition, canvasGraphics, m_RaycastResults);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//遍历m_RaycastResults，判断Graphic的方向向量和Camera的方向向量是否相交，然后判断Graphic是否在Camera的前面，并且距离小于等于hitDistance，满足了这些条件，才会把它打包成RaycastResult添加到resultAppendList里。</span></span><br><span class=\"line\">    <span class=\"built_in\">int</span> totalCount = m_RaycastResults.Count;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> index = <span class=\"number\">0</span>; index &lt; totalCount; index++)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> go = m_RaycastResults[index].gameObject;</span><br><span class=\"line\">        <span class=\"built_in\">bool</span> appendGraphic = <span class=\"literal\">true</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (ignoreReversedGraphics)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (currentEventCamera == <span class=\"literal\">null</span>)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                <span class=\"comment\">// If we dont have a camera we know that we should always be facing forward</span></span><br><span class=\"line\">                <span class=\"keyword\">var</span> dir = go.transform.rotation * Vector3.forward;</span><br><span class=\"line\">                appendGraphic = Vector3.Dot(Vector3.forward, dir) &gt; <span class=\"number\">0</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">else</span></span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                <span class=\"comment\">// If we have a camera compare the direction against the cameras forward.</span></span><br><span class=\"line\">                <span class=\"keyword\">var</span> cameraForward = currentEventCamera.transform.rotation * Vector3.forward * currentEventCamera.nearClipPlane;</span><br><span class=\"line\">                appendGraphic = Vector3.Dot(go.transform.position - currentEventCamera.transform.position - cameraForward, go.transform.forward) &gt;= <span class=\"number\">0</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (appendGraphic)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"built_in\">float</span> distance = <span class=\"number\">0</span>;</span><br><span class=\"line\">            Transform trans = go.transform;</span><br><span class=\"line\">            Vector3 transForward = trans.forward;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (currentEventCamera == <span class=\"literal\">null</span> || canvas.renderMode == RenderMode.ScreenSpaceOverlay)</span><br><span class=\"line\">                distance = <span class=\"number\">0</span>;</span><br><span class=\"line\">            <span class=\"keyword\">else</span></span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                <span class=\"comment\">// http://geomalgorithms.com/a06-_intersect-2.html</span></span><br><span class=\"line\">                distance = (Vector3.Dot(transForward, trans.position - ray.origin) / Vector3.Dot(transForward, ray.direction));</span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"comment\">// Check to see if the go is behind the camera.</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (distance &lt; <span class=\"number\">0</span>)</span><br><span class=\"line\">                    <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (distance &gt;= hitDistance)</span><br><span class=\"line\">                <span class=\"keyword\">continue</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">var</span> castResult = <span class=\"keyword\">new</span> RaycastResult</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                ......</span><br><span class=\"line\">            &#125;;</span><br><span class=\"line\">            resultAppendList.Add(castResult);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n\n<p>上述代码中调用了<code>Raycast</code>函数重载，作用是向屏幕投射射线并收集屏幕下方所有挂载了<code>Graphic</code>脚本的游戏对象，该函数内容为：</p>\n<figure class=\"highlight csharp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">Raycast</span>(<span class=\"params\">Canvas canvas, Camera eventCamera, Vector2 pointerPosition, IList&lt;Graphic&gt; foundGraphics, List&lt;Graphic&gt; results</span>)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"comment\">// Necessary for the event system</span></span><br><span class=\"line\">    <span class=\"comment\">//遍历场景内Graphic对象(挂载Graphic脚本的对象)</span></span><br><span class=\"line\">    <span class=\"built_in\">int</span> totalCount = foundGraphics.Count;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"built_in\">int</span> i = <span class=\"number\">0</span>; i &lt; totalCount; ++i)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        Graphic graphic = foundGraphics[i];</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// -1 means it hasn&#x27;t been processed by the canvas, which means it isn&#x27;t actually drawn</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!graphic.raycastTarget || graphic.canvasRenderer.cull || graphic.depth == <span class=\"number\">-1</span>)</span><br><span class=\"line\">            <span class=\"keyword\">continue</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//目标点是否在矩阵中</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!RectTransformUtility.RectangleContainsScreenPoint(graphic.rectTransform, pointerPosition, eventCamera, graphic.raycastPadding))</span><br><span class=\"line\">            <span class=\"keyword\">continue</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//超出摄像机范围</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (eventCamera != <span class=\"literal\">null</span> &amp;&amp; eventCamera.WorldToScreenPoint(graphic.rectTransform.position).z &gt; eventCamera.farClipPlane)</span><br><span class=\"line\">            <span class=\"keyword\">continue</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//调用符合条件的Graphic的Raycast方法</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (graphic.Raycast(pointerPosition, eventCamera))</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            s_SortedGraphics.Add(graphic);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    s_SortedGraphics.Sort((g1, g2) =&gt; g2.depth.CompareTo(g1.depth));</span><br><span class=\"line\">    totalCount = s_SortedGraphics.Count;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"built_in\">int</span> i = <span class=\"number\">0</span>; i &lt; totalCount; ++i)</span><br><span class=\"line\">        results.Add(s_SortedGraphics[i]);</span><br><span class=\"line\"></span><br><span class=\"line\">    s_SortedGraphics.Clear();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p> <strong>函数中又调用了<code>Graphic</code>类的<code>Raycast</code>函数，它主要是做两件事，一件是使用<code>RectTransform</code>的值过滤元素，另一件是使用<code>Raycast</code>函数确定射线击中的元素。</strong> <code>RawImage</code>、<code>Image</code>和<code>Text</code>都间接继承自<code>Graphic</code>。</p>\n<p><img src=\"https://pic2.zhimg.com/80/v2-b9be049e2a433d8a8437328d49e8dc4d_720w.jpg\"></p>\n<figure class=\"highlight csharp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">virtual</span> <span class=\"built_in\">bool</span> <span class=\"title\">Raycast</span>(<span class=\"params\">Vector2 sp, Camera eventCamera</span>)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!isActiveAndEnabled)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//UI元素,比如Image,Button等</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> t = transform;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">var</span> components = ListPool&lt;Component&gt;.Get();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">bool</span> ignoreParentGroups = <span class=\"literal\">false</span>;</span><br><span class=\"line\">    <span class=\"built_in\">bool</span> continueTraversal = <span class=\"literal\">true</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (t != <span class=\"literal\">null</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        t.GetComponents(components);</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &lt; components.Count; i++)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">            Debug.Log(components[i].name);</span><br><span class=\"line\">            <span class=\"keyword\">var</span> canvas = components[i] <span class=\"keyword\">as</span> Canvas;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (canvas != <span class=\"literal\">null</span> &amp;&amp; canvas.overrideSorting)</span><br><span class=\"line\">                continueTraversal = <span class=\"literal\">false</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">//获取ICanvasRaycastFilter组件(Image,Mask,RectMask2D)</span></span><br><span class=\"line\">            <span class=\"keyword\">var</span> filter = components[i] <span class=\"keyword\">as</span> ICanvasRaycastFilter;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (filter == <span class=\"literal\">null</span>)</span><br><span class=\"line\">                <span class=\"keyword\">continue</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">var</span> raycastValid = <span class=\"literal\">true</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">//判断sp点是否在有效的范围内</span></span><br><span class=\"line\">            <span class=\"keyword\">var</span> <span class=\"keyword\">group</span> = components[i] <span class=\"keyword\">as</span> CanvasGroup;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (<span class=\"keyword\">group</span> != <span class=\"literal\">null</span>)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (ignoreParentGroups == <span class=\"literal\">false</span> &amp;&amp; <span class=\"keyword\">group</span>.ignoreParentGroups)</span><br><span class=\"line\">                &#123;</span><br><span class=\"line\">                    ignoreParentGroups = <span class=\"literal\">true</span>;</span><br><span class=\"line\">                    raycastValid = filter.IsRaycastLocationValid(sp, eventCamera);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (!ignoreParentGroups)</span><br><span class=\"line\">                    raycastValid = filter.IsRaycastLocationValid(sp, eventCamera);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">else</span></span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                raycastValid = filter.IsRaycastLocationValid(sp, eventCamera);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (!raycastValid)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                ListPool&lt;Component&gt;.Release(components);</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">//遍历它的父物体</span></span><br><span class=\"line\">        t = continueTraversal ? t.parent : <span class=\"literal\">null</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    ListPool&lt;Component&gt;.Release(components);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这里也使用了<code>ICanvasRaycastFilter</code>接口中的<code>IsRaycastLocationValid</code>函数，主要还是判断点的位置是否有效，不过这里使用了Alpha测试。Image、Mask以及RectMask2D都继承了该接口。</p>\n<p><img src=\"https://pic4.zhimg.com/80/v2-d80ee9c4b4f5c61ef1c05a1fc793bfab_720w.jpg\"></p>\n<figure class=\"highlight csharp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">virtual</span> <span class=\"built_in\">bool</span> <span class=\"title\">IsRaycastLocationValid</span>(<span class=\"params\">Vector2 screenPoint, Camera eventCamera</span>)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"comment\">//小于阈值(alphaHitTestMinimumThreshold)的Alpha值将导致射线事件穿透图像。 </span></span><br><span class=\"line\">    <span class=\"comment\">//值为1将导致只有完全不透明的像素在图像上注册相应射线事件。</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (alphaHitTestMinimumThreshold &lt;= <span class=\"number\">0</span>)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (alphaHitTestMinimumThreshold &gt; <span class=\"number\">1</span>)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (activeSprite == <span class=\"literal\">null</span>)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    Vector2 local;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!RectTransformUtility.ScreenPointToLocalPointInRectangle(rectTransform, screenPoint, eventCamera, <span class=\"keyword\">out</span> local))</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    Rect rect = GetPixelAdjustedRect();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Convert to have lower left corner as reference point.</span></span><br><span class=\"line\">    local.x += rectTransform.pivot.x * rect.width;</span><br><span class=\"line\">    local.y += rectTransform.pivot.y * rect.height;</span><br><span class=\"line\"></span><br><span class=\"line\">    local = MapCoordinate(local, rect);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Convert local coordinates to texture space.</span></span><br><span class=\"line\">    Rect spriteRect = activeSprite.textureRect;</span><br><span class=\"line\">    <span class=\"built_in\">float</span> x = (spriteRect.x + local.x) / activeSprite.texture.width;</span><br><span class=\"line\">    <span class=\"built_in\">float</span> y = (spriteRect.y + local.y) / activeSprite.texture.height;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">try</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> activeSprite.texture.GetPixelBilinear(x, y).a &gt;= alphaHitTestMinimumThreshold;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">catch</span> (UnityException e)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        Debug.LogError(<span class=\"string\">&quot;Using alphaHitTestMinimumThreshold greater than 0 on Image whose sprite texture cannot be read. &quot;</span> + e.Message + <span class=\"string\">&quot; Also make sure to disable sprite packing for this sprite.&quot;</span>, <span class=\"keyword\">this</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"EventData\"><a href=\"#EventData\" class=\"headerlink\" title=\"EventData\"></a><code>EventData</code></h3><p><code>EventData</code>用以存储事件信息，涉及到的东西不多，不展开讲解，层级关系如下图所示</p>\n<p><img src=\"https://pic1.zhimg.com/80/v2-a72d1e210d9964fe63a440b4172d84ac_720w.jpg\"></p>\n<h2 id=\"实战：为Button的点击事件添加参数\"><a href=\"#实战：为Button的点击事件添加参数\" class=\"headerlink\" title=\"实战：为Button的点击事件添加参数\"></a><strong>实战：为Button的点击事件添加参数</strong></h2><p>在执行<code>Button</code>点击事件时，有些情况下我们需要获取触发事件的<code>Button</code>对象信息，这时可以自己实现一个<code>Button</code>点击事件</p>\n<figure class=\"highlight csharp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"><span class=\"doctag\">///</span> <span class=\"doctag\">&lt;summary&gt;</span></span></span><br><span class=\"line\"><span class=\"comment\"><span class=\"doctag\">///</span> UI事件监听器(与Button等UI挂在同一个物体上）：管理所有UGUI事件，提供事件参数类</span></span><br><span class=\"line\"><span class=\"comment\"><span class=\"doctag\">///</span> 若想看所有相关委托  自行查看EventTrigger类</span></span><br><span class=\"line\"><span class=\"comment\"><span class=\"doctag\">///</span> <span class=\"doctag\">&lt;/summary&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title\">UIEventListener</span> : <span class=\"title\">MonoBehaviour</span>, <span class=\"title\">IPointerClickHandler</span>, <span class=\"title\">IPointerDownHandler</span>, <span class=\"title\">IPointerUpHandler</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"comment\">//2.定义委托</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"built_in\">delegate</span> <span class=\"keyword\">void</span> <span class=\"title\">PointerEventHandler</span>(<span class=\"params\">PointerEventData eventData</span>)</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//3.声明事件</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">event</span> PointerEventHandler PointerClick;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">event</span> PointerEventHandler PointerDown;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">event</span> PointerEventHandler PointerUp;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\"><span class=\"doctag\">///</span> <span class=\"doctag\">&lt;summary&gt;</span></span></span><br><span class=\"line\">    <span class=\"comment\"><span class=\"doctag\">///</span> 通过变换组件获取事件监听器</span></span><br><span class=\"line\">    <span class=\"comment\"><span class=\"doctag\">///</span> <span class=\"doctag\">&lt;/summary&gt;</span></span></span><br><span class=\"line\">    <span class=\"comment\"><span class=\"doctag\">///</span> <span class=\"doctag\">&lt;param name=&quot;transform&quot;&gt;</span><span class=\"doctag\">&lt;/param&gt;</span></span></span><br><span class=\"line\">    <span class=\"comment\"><span class=\"doctag\">///</span> <span class=\"doctag\">&lt;returns&gt;</span><span class=\"doctag\">&lt;/returns&gt;</span></span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> UIEventListener <span class=\"title\">GetEventListener</span>(<span class=\"params\">Transform transform</span>)</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        UIEventListener uIEventListener = transform.GetComponent&lt;UIEventListener&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (uIEventListener == <span class=\"literal\">null</span>)</span><br><span class=\"line\">            uIEventListener = transform.gameObject.AddComponent&lt;UIEventListener&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> uIEventListener;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//1.实现接口</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">OnPointerClick</span>(<span class=\"params\">PointerEventData eventData</span>)</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"comment\">//表示抽象的有  抽象类  接口（多类抽象行为）  委托（一类抽象行为）</span></span><br><span class=\"line\">        <span class=\"comment\">//4.引发事件</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (PointerClick != <span class=\"literal\">null</span>)</span><br><span class=\"line\">            PointerClick(eventData);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">OnPointerDown</span>(<span class=\"params\">PointerEventData eventData</span>)</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        PointerDown?.Invoke(eventData);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">OnPointerUp</span>(<span class=\"params\">PointerEventData eventData</span>)</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        PointerUp?.Invoke(eventData);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>使用的时候，我们只需要将它挂载到<code>Button</code>组件上，然后在<code>PointerClick</code>事件中添加自己的处理函数。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a><strong>总结</strong></h2><p><code>Button</code>点击事件怎么触发的呢？首先是<code>EventSystem</code>在<code>Update</code>中调用当前输入模块的<code>Process</code>方法处理所有的鼠标事件，并且输入模块会调用<code>RaycastAll</code>来得到目标信息，通过冒泡的方式找到事件实际接收者并执行点击事件(这只是总体流程，中间省略很多具体步骤)。</p>\n<p><img src=\"https://pic2.zhimg.com/80/v2-46b1ca8927625fb9ffb2cf94092b4651_720w.jpg\"></p>\n<p>最后来一张层级关系图</p>\n<p><img src=\"https://pic2.zhimg.com/80/v2-9a23d2a2f220e3e8100607ddc0999721_720w.jpg\"></p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"01-从Button开始解读UGUI源码\"><a href=\"#01-从Button开始解读UGUI源码\" class=\"headerlink\" title=\"01 | 从Button开始解读UGUI源码\"></a><strong>01 | 从<code>Button</code>开始解读<code>UGUI</code>源码</strong></h2><p>在Unity中，Button是我们最常用的组件之一了，它使用起来非常简单，例如监听一个Button点击事件</p>\n<figure class=\"highlight csharp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">GetComponent&lt;Button&gt;().onClick.AddListener(() =&gt; &#123; </span><br><span class=\"line\">    ...<span class=\"comment\">//按钮点击的处理逻辑</span></span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p>这样使用没有任何问题，但有时候我们会有疑问，为什么点击按钮<code>onClick</code>事件就会被触发呢？如何从回调函数中获取按钮的参数？让我们从源码中寻找答案。</p>\n<h2 id=\"查看源码前的配置\"><a href=\"#查看源码前的配置\" class=\"headerlink\" title=\"查看源码前的配置\"></a><strong>查看源码前的配置</strong></h2><p>为了能够方便的查阅源码以及进行代码调试，需要重新导入<code>UGUI</code>包。新建Unity项目，找到<code>Project/Packages/Unity UI</code>，右键 <code>Show in Explorer</code>，将其复制到任意一个新的文件夹中(记住保存的位置，待会需要引用)。</p>\n<p>接下来打开<code>Window/Package Manager</code></p>\n<p><img src=\"https://pic1.zhimg.com/80/v2-3ccfbcede96e7528a3b02780975fa198_720w.jpg\"></p>\n<p>找到<code>Unity UI</code>，将其<code>Remove</code></p>\n<p><img src=\"https://pic1.zhimg.com/80/v2-2f23bd59190b84d78c1249ac0ebde634_720w.jpg\"></p>\n<p>然后点击<code>“+”</code>号，选择<code>Add package form disk...</code>，找到之前保存的UI包，进入目录后选中<code>package.json</code>，点击打开。</p>\n<p><img src=\"https://pic1.zhimg.com/80/v2-63a9b186c1eaf811361227c1e2d752e0_720w.jpg\"></p>\n<p>大功告成，现在我们可以查看&#x2F;修改<code>UGUI</code>的源码了。</p>\n<h2 id=\"探究UGUI源码\"><a href=\"#探究UGUI源码\" class=\"headerlink\" title=\"探究UGUI源码\"></a><strong>探究<code>UGUI</code>源码</strong></h2><h3 id=\"Button的调用链\"><a href=\"#Button的调用链\" class=\"headerlink\" title=\"Button的调用链\"></a><strong><code>Button</code>的调用链</strong></h3><p>通过<code>F12</code>打开<code>Button</code>代码，容易发现它继承<code>Selectable</code>类，同时还继承了<code>IPointerClickHandler</code>、<code>ISubmitHandler</code>接口，这两个接口分别会在鼠标点击、点击提交按钮时调用它们的回调函数。</p>\n<figure class=\"highlight text\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> public class Button : Selectable, IPointerClickHandler, ISubmitHandler</span><br><span class=\"line\"> &#123;</span><br><span class=\"line\">     [Serializable]</span><br><span class=\"line\">     //定义一个点击事件</span><br><span class=\"line\">     public class ButtonClickedEvent : UnityEvent &#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">     // 实例化一个ButtonClickedEvent的事件</span><br><span class=\"line\">     [FormerlySerializedAs(&quot;onClick&quot;)]</span><br><span class=\"line\">     [SerializeField]</span><br><span class=\"line\">     private ButtonClickedEvent m_OnClick = new ButtonClickedEvent();</span><br><span class=\"line\"></span><br><span class=\"line\">     protected Button()</span><br><span class=\"line\">     &#123;&#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">     //常用的onClick.AddListener()就是监听这个事件</span><br><span class=\"line\">     public ButtonClickedEvent onClick</span><br><span class=\"line\">     &#123;</span><br><span class=\"line\">         get &#123; return m_OnClick; &#125;</span><br><span class=\"line\">         set &#123; m_OnClick = value; &#125;</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\">   </span><br><span class=\"line\">     //如果按钮处于活跃状态并且可交互(Interactable设置为true)，则触发事件</span><br><span class=\"line\">     private void Press()</span><br><span class=\"line\">     &#123;</span><br><span class=\"line\">         if (!IsActive() || !IsInteractable())</span><br><span class=\"line\">             return;</span><br><span class=\"line\"></span><br><span class=\"line\">         UISystemProfilerApi.AddMarker(&quot;Button.onClick&quot;, this);</span><br><span class=\"line\">         m_OnClick.Invoke();</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">     //鼠标点击时调用该函数，继承自 IPointerClickHandler 接口</span><br><span class=\"line\">     public virtual void OnPointerClick(PointerEventData eventData)</span><br><span class=\"line\">     &#123;</span><br><span class=\"line\">         if (eventData.button != PointerEventData.InputButton.Left)</span><br><span class=\"line\">             return;</span><br><span class=\"line\"></span><br><span class=\"line\">         Press();</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">     //按下“提交”键后触发(需要先选中该游戏物体)，继承自 ISubmitHandler</span><br><span class=\"line\">     //&quot;提交&quot;键可以在 Edit-&gt;Project Settings-&gt;Input-&gt;Submit 中自定义</span><br><span class=\"line\">     public virtual void OnSubmit(BaseEventData eventData)&#123;...&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">     private IEnumerator OnFinishSubmit()&#123;...&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><code>IPointerClickHandler</code>接口仅包含一个<code>OnPointerClick()</code>方法，当鼠标点击时会调用该接口的方法。而<code>Button</code>能触发点击事件是因为继承自<code>IPointerClickHandler</code>接口，并且重写了<code>OnPointerClick</code>方法。</p>\n<p>那<code>IPointerClickHandler</code>接口的方法又是被谁调用的呢？查找引用，发现是<code>ExecuteEvents</code>类的<code>Execute</code>方法(该类相当于事件执行器，提供了许多通用的事件处理方法)，并且<code>Execute</code>方法赋值给<code>s_PointerClickHandler</code>字段。</p>\n<figure class=\"highlight csharp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">readonly</span> EventFunction&lt;IPointerClickHandler&gt; s_PointerClickHandler = Execute;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">Execute</span>(<span class=\"params\">IPointerClickHandler handler, BaseEventData eventData</span>)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    handler.OnPointerClick(ValidateEventData&lt;PointerEventData&gt;(eventData));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p> <strong>为了能看的更清楚，总结一下调用关系，即<code>Button</code>继承自<code>Selectable</code>、<code>IPointercliClickHandler</code>、<code>ISubmitHandler</code>，而<code>IPointercliClickHandler</code>、<code>ISubmitHandler</code>继承自<code>IEventSystemHandler</code>，<code>ExecuteEvent</code>会在鼠标松开时通过<code>Execute</code>函数调用<code>IPointercliClickHandler</code>、<code>ISubmitHandler</code>接口的方法，从而触发<code>Button</code>的<code>onClick</code>事件</strong> ，如下图所示</p>\n<p><img src=\"https://pic3.zhimg.com/80/v2-1e8f7c467c473bd3b3315b3b6be8280a_720w.jpg\"></p>\n<p>继续往上找，<code>ExecuteEvents</code>类中还定义了一个<code>EventFunction&lt;T1&gt;</code>的泛型委托以及该委托类型的属性，这个返回<code>s_PointerClickHandler</code>，要查找谁触发的点击事件，只需要找到谁调用了<code>pointerClickHandler</code>即可</p>\n<figure class=\"highlight csharp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"built_in\">delegate</span> <span class=\"keyword\">void</span> <span class=\"title\">EventFunction</span>&lt;<span class=\"title\">T1</span>&gt;(<span class=\"params\">T1 handler, BaseEventData eventData</span>)</span>;</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> EventFunction&lt;IPointerClickHandler&gt; pointerClickHandler</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">get</span> &#123; <span class=\"keyword\">return</span> s_PointerClickHandler; &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>容易发现，<code>StandaloneInputModule</code>和<code>TouchInputModule</code>类对其有调用，这两个类继承自<code>BaseInput</code>，主要用以处理鼠标、键盘、控制器等设备的输入， <strong><code>EventSystem</code>类会在<code>Update</code>中每帧检查可用的输入模块的状态是否发生变化，并调用<code>TickModules()</code>和当前输入模块(<code>m_CurrentInputModule</code>)的<code>Process()</code>函数</strong> (后面会进行讲解)。下面是<code>StandaloneInputModule</code>的部分代码，它继承自<code>BaseInputModule</code></p>\n<figure class=\"highlight csharp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 计算和处理任何鼠标按钮状态的变化</span></span><br><span class=\"line\"><span class=\"comment\">//Process函数间接对其进行调用（调用链过长，不一一展示)</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">ProcessMousePress</span>(<span class=\"params\">MouseButtonEventData data</span>)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    ...<span class=\"comment\">//省略部分代码</span></span><br><span class=\"line\">       <span class=\"comment\">//鼠标按键抬起时调用（按键包括鼠标左键、中间滑轮和右键）</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (data.ReleasedThisFrame())</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        ReleaseMouse(pointerEvent, currentOverGo);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//满足松开鼠标的条件时调用</span></span><br><span class=\"line\"><span class=\"comment\">//currentOverGo ：当前选中的游戏物体</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">ReleaseMouse</span>(<span class=\"params\">PointerEventData pointerEvent, GameObject currentOverGo</span>)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    ...<span class=\"comment\">//省略部分代码</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (pointerEvent.pointerPress == pointerUpHandler &amp;&amp; pointerEvent.eligibleForClick)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"comment\">//执行Execute函数，传入ExecuteEvents.pointerClickHandler委托</span></span><br><span class=\"line\">        ExecuteEvents.Execute(pointerEvent.pointerPress, pointerEvent, ExecuteEvents.pointerClickHandler);</span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>查看<code>ExecuteEvents.Execute</code>的实现</p>\n<blockquote>\n<p>上面已经查看过<code>Execute</code>方法，为什么现在又出来一个？<br>因为<code>ExecuteEvents</code>中有N多个重载函数</p>\n</blockquote>\n<figure class=\"highlight csharp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//target ： 需要执行事件的游戏对象</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"built_in\">bool</span> <span class=\"title\">Execute</span>&lt;<span class=\"title\">T</span>&gt;(<span class=\"params\">GameObject target, BaseEventData eventData, EventFunction&lt;T&gt; functor</span>) <span class=\"keyword\">where</span> T : IEventSystemHandler</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> internalHandlers = s_HandlerListPool.Get();</span><br><span class=\"line\">    <span class=\"comment\">//获取target对象的事件</span></span><br><span class=\"line\">    GetEventList&lt;T&gt;(target, internalHandlers);</span><br><span class=\"line\">    <span class=\"comment\">//  if (s_InternalHandlers.Count &gt; 0)</span></span><br><span class=\"line\">    <span class=\"comment\">//      Debug.Log(&quot;Executinng &quot; + typeof (T) + &quot; on &quot; + target);</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &lt; internalHandlers.Count; i++)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        T arg;</span><br><span class=\"line\">        <span class=\"keyword\">try</span></span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            arg = (T)internalHandlers[i];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">catch</span> (Exception e)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">var</span> temp = internalHandlers[i];</span><br><span class=\"line\">            Debug.LogException(<span class=\"keyword\">new</span> Exception(<span class=\"built_in\">string</span>.Format(<span class=\"string\">&quot;Type &#123;0&#125; expected &#123;1&#125; received.&quot;</span>, <span class=\"keyword\">typeof</span>(T).Name, temp.GetType().Name), e));</span><br><span class=\"line\">            <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">try</span></span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"comment\">//执行EventFunction&lt;T&gt;委托,例如pointerClickHandler(arg,eventData)</span></span><br><span class=\"line\">            functor(arg, eventData);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">catch</span> (Exception e)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            Debug.LogException(e);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">var</span> handlerCount = internalHandlers.Count;</span><br><span class=\"line\">    s_HandlerListPool.Release(internalHandlers);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> handlerCount &gt; <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>也就是说，<code>EventSystem</code>会在<code>Update()</code>中调用当前可用<code>BaseInputModule</code>的<code>Process()</code>方法，该方法会处理鼠标的按下、抬起等事件，当鼠标抬起时调用<code>ReleaseMouse()</code>方法，并最终调用<code>Execute()</code>方法并触发<code>IPointerClick</code>事件。</strong> 如下图所示(为了简洁，类图并不完整)</p>\n<p><img src=\"https://pic2.zhimg.com/80/v2-271819772d80baa805565dc9182d3ab5_720w.jpg\"></p>\n<blockquote>\n<p>ReleaseMouse()是否只有鼠标左键抬起才会触发？<br>鼠标左、中、右键都会触发该函数，只不过<code>Button</code>在实现<code>OnPointerClick()</code>函数时忽略了鼠标中键和右键，使得只有左键能触发<code>Button</code>的点击事件</p>\n</blockquote>\n<p>但现在还存在一个问题，怎么知道上述代码中事件执行目标<code>target</code>的值呢？探究这个问题之前，我们需要先对<code>UGUI</code>源码有个总体的认识，因为它涉及的知识点比较多。</p>\n<h2 id=\"事件系统整体概述\"><a href=\"#事件系统整体概述\" class=\"headerlink\" title=\"事件系统整体概述\"></a><strong>事件系统整体概述</strong></h2><p>我们先看<code>EventSystem</code>源码在文件夹中的分类</p>\n<p><img src=\"https://pic4.zhimg.com/80/v2-15edd68d6268be3dd761ac92e6b6961b_720w.jpg\"></p>\n<p>从图中就可以看出主要 <strong>包含三个子板块，分别是<code>EvnetData</code>、<code>InputModules</code>和<code>Raycasters</code></strong> 。</p>\n<p>再看一个整体的类图，类图中包括了许多重要的类，如<code>EventSystem</code>、<code>BaseRaycast</code>、<code>BaseInputModule</code>等，它们都是继承自<code>UIBehaviour</code>，而<code>UIBehaviour</code>又是继承<code>MonoBehaviour</code>。（类图并不完整，只涉及部分类）</p>\n<p><img src=\"https://pic4.zhimg.com/80/v2-d401d582568a761d54f89a64a8371a93_720w.jpg\"></p>\n<p>接下来对这些内容进行详细讲解。</p>\n<h3 id=\"EventSystem类\"><a href=\"#EventSystem类\" class=\"headerlink\" title=\"EventSystem类\"></a><strong><code>EventSystem</code>类</strong></h3><p>事件系统主要是 <strong>基于输入(键盘、鼠标、触摸或自定义输入)向应用程序中的对象发送事件</strong> ，当然这需要其他组件的配合。当你在<code>GameObject</code>中添加<code>EventSystem</code>时，你会发现它并没有太多的功能，这是因为 <strong><code>EventSystem</code>本身被设计成事件系统不同模块之间通信的管理者和推动者</strong> ，它主要包含以下功能：</p>\n<ul>\n<li><strong>管理哪个游戏对象被认为是选中的</strong></li>\n<li><strong>管理正在使用的输入模块</strong></li>\n<li><strong>管理射线检测(如果需要)</strong></li>\n<li><strong>根据需要更新所有输入模块</strong></li>\n</ul>\n<h3 id=\"管理输入模块\"><a href=\"#管理输入模块\" class=\"headerlink\" title=\"管理输入模块\"></a>管理输入模块</h3><p>下面看一下具体代码。首先是声明了<code>BaseInputModule</code>类型的<code>List</code>和变量，用来保存输入模块(<code>Module</code>)</p>\n<figure class=\"highlight csharp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//系统输入模块</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> List&lt;BaseInputModule&gt; m_SystemInputModules = <span class=\"keyword\">new</span> List&lt;BaseInputModule&gt;();</span><br><span class=\"line\"><span class=\"comment\">//当前输入模块</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> BaseInputModule m_CurrentInputModule;</span><br></pre></td></tr></table></figure>\n\n<p>接下来，它会在<code>Update</code>中处理这些模块，调用<code>TickModules</code>方法，更新每一个模块，并且会在满足条件的情况下调用当前模块的<code>Process</code>方法</p>\n<figure class=\"highlight csharp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">virtual</span> <span class=\"keyword\">void</span> <span class=\"title\">Update</span>()</span></span><br><span class=\"line\"> &#123;</span><br><span class=\"line\">    <span class=\"comment\">//遍历m_SystemInputModules，如果其中的Module不为null，则调用UpdateModule方法</span></span><br><span class=\"line\">     TickModules();</span><br><span class=\"line\"></span><br><span class=\"line\">     <span class=\"comment\">//遍历m_SystemInputModules判断其中的输入模块是否支持当前平台</span></span><br><span class=\"line\">     <span class=\"comment\">//如果支持并且可以激活，则将其赋值给当前输入模块并Break</span></span><br><span class=\"line\">     <span class=\"built_in\">bool</span> changedModule = <span class=\"literal\">false</span>;</span><br><span class=\"line\">     <span class=\"keyword\">var</span> systemInputModulesCount = m_SystemInputModules.Count;</span><br><span class=\"line\">     <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &lt; systemInputModulesCount; i++)</span><br><span class=\"line\">     &#123;</span><br><span class=\"line\">         <span class=\"keyword\">var</span> module = m_SystemInputModules[i];</span><br><span class=\"line\">         <span class=\"keyword\">if</span> (module.IsModuleSupported() &amp;&amp; module.ShouldActivateModule())</span><br><span class=\"line\">         &#123;</span><br><span class=\"line\">             <span class=\"keyword\">if</span> (m_CurrentInputModule != module)</span><br><span class=\"line\">             &#123;</span><br><span class=\"line\">                 ChangeEventModule(module);</span><br><span class=\"line\">                 changedModule = <span class=\"literal\">true</span>;</span><br><span class=\"line\">             &#125;</span><br><span class=\"line\">             <span class=\"keyword\">break</span>;</span><br><span class=\"line\">         &#125;</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">     <span class=\"comment\">//如果上面没找到符合条件的模块，则使用第一个支持当前平台的模块</span></span><br><span class=\"line\">     <span class=\"keyword\">if</span> (m_CurrentInputModule == <span class=\"literal\">null</span>)</span><br><span class=\"line\">     &#123;</span><br><span class=\"line\">         <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &lt; systemInputModulesCount; i++)</span><br><span class=\"line\">         &#123;</span><br><span class=\"line\">             <span class=\"keyword\">var</span> module = m_SystemInputModules[i];</span><br><span class=\"line\">             <span class=\"keyword\">if</span> (module.IsModuleSupported())</span><br><span class=\"line\">             &#123;</span><br><span class=\"line\">                 ChangeEventModule(module);</span><br><span class=\"line\">                 changedModule = <span class=\"literal\">true</span>;</span><br><span class=\"line\">                 <span class=\"keyword\">break</span>;</span><br><span class=\"line\">             &#125;</span><br><span class=\"line\">         &#125;</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">     <span class=\"comment\">//如果当前模块没有发生变化并且当前模块不为空</span></span><br><span class=\"line\">     <span class=\"keyword\">if</span> (!changedModule &amp;&amp; m_CurrentInputModule != <span class=\"literal\">null</span>)</span><br><span class=\"line\">         m_CurrentInputModule.Process();</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">TickModules</span>()</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> systemInputModulesCount = m_SystemInputModules.Count;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &lt; systemInputModulesCount; i++)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (m_SystemInputModules[i] != <span class=\"literal\">null</span>)</span><br><span class=\"line\">            m_SystemInputModules[i].UpdateModule();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><code>Process()</code>方法主要是将各种输入事件（如点击、拖拽等事件）传递给<code>EventSystem</code>当前选中的<code>GameObject</code>(即<code>m_CurrentSelected</code>)</p>\n<h3 id=\"管理选中的游戏对象\"><a href=\"#管理选中的游戏对象\" class=\"headerlink\" title=\"管理选中的游戏对象\"></a>管理选中的游戏对象</h3><p>当场景中的游戏物体(<code>Button</code>、<code>Dropdown</code>、<code>InputField</code>等)被选中时，会通知之前选中的对象执行被取消(<code>OnDeselect</code>)事件，通知当前选中的对象执行选中(<code>OnSelect</code>)事件，部分代码如下</p>\n<figure class=\"highlight csharp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">SetSelectedGameObject</span>(<span class=\"params\">GameObject selected, BaseEventData pointer</span>)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    ......<span class=\"comment\">//省略部分代码</span></span><br><span class=\"line\">    <span class=\"comment\">//通知之前被选中取消选中</span></span><br><span class=\"line\">    ExecuteEvents.Execute(m_CurrentSelected, pointer, ExecuteEvents.deselectHandler);</span><br><span class=\"line\">    m_CurrentSelected = selected;</span><br><span class=\"line\">    <span class=\"comment\">//通知当前物体被选中</span></span><br><span class=\"line\">    ExecuteEvents.Execute(m_CurrentSelected, pointer, ExecuteEvents.selectHandler);</span><br><span class=\"line\">    m_SelectionGuard = <span class=\"literal\">false</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"管理射线检测\"><a href=\"#管理射线检测\" class=\"headerlink\" title=\"管理射线检测\"></a>管理射线检测</h3><p><code>EventSystem</code>中，还有一个非常重要的函数<code>RaycastAll()</code>，主要是获取目标。它被<code>PointerInputModule</code>类调用，大致来说是当鼠标设备可用或触摸板被使用时调用。</p>\n<figure class=\"highlight csharp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">RaycastAll</span>(<span class=\"params\">PointerEventData eventData, List&lt;RaycastResult&gt; raycastResults</span>)</span></span><br><span class=\"line\"> &#123;</span><br><span class=\"line\">     raycastResults.Clear();</span><br><span class=\"line\">     <span class=\"comment\">//获取BaseRaycast对象</span></span><br><span class=\"line\">     <span class=\"keyword\">var</span> modules = RaycasterManager.GetRaycasters();</span><br><span class=\"line\">     <span class=\"keyword\">var</span> modulesCount = modules.Count;</span><br><span class=\"line\">     <span class=\"keyword\">for</span> (<span class=\"built_in\">int</span> i = <span class=\"number\">0</span>; i &lt; modulesCount; ++i)</span><br><span class=\"line\">     &#123;</span><br><span class=\"line\">         <span class=\"keyword\">var</span> module = modules[i];</span><br><span class=\"line\">         <span class=\"keyword\">if</span> (module == <span class=\"literal\">null</span> || !module.IsActive())</span><br><span class=\"line\">             <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">        <span class=\"comment\">//调用Raycast方法，</span></span><br><span class=\"line\">         module.Raycast(eventData, raycastResults);</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">     raycastResults.Sort(s_RaycastComparer);</span><br><span class=\"line\"> &#125;</span><br></pre></td></tr></table></figure>\n\n<p>它首先获取所有的<code>BaseRaycast</code>对象，然后调用它的<code>Raycast</code>方法，用以获取屏幕某个点下的所有目标（这个方法具体功能及实现的会在<code>Raycast</code>模块中进行讲解)，最后对得到的结果进行排序，大部分情况都是根据深度(<code>Depth</code>)进行排序，在一些情况下也会使用距离(<code>Distance</code>)、排序顺序(<code>SortingOrder</code>，如果是<code>UI</code>元素则是根据<code>Canvas</code>面板的<code>Sort order</code>值，<code>3D</code>物体默认是0)或者排序层级(<code>Sorting Layer</code>)等作为排序依据。</p>\n<p>讲了这么一大堆，来张图总结一下。**<code>EventSystem</code>会在<code>Update</code>中调用输入模块的<code>Process</code>方法来处理输入消息，<code>PointerInputModule</code>会调用<code>EventSystem</code>中的<code>RaycastAll</code>方法进行射线检测，<code>RaycastAll</code>又会调用<code>BastRaycaster</code>的<code>Raycast</code>方法执行具体的射线检测操作，主要是获取被选中的目标信息。**</p>\n<p><img src=\"https://pic4.zhimg.com/80/v2-9685293899700c01f1d93245f0deda87_720w.jpg\"></p>\n<p>简单概括一下<code>UML</code>图的含义，比如实线+三角形表示继承，实线+箭头表示关联，虚线+箭头表示依赖，关联和依赖的区别主要是引用其他类作为成员变量代表的是关联关系，将其他类作为局部变量、方法参数，或者引用它的静态方法，就属于依赖关系。</p>\n<h3 id=\"InputModules\"><a href=\"#InputModules\" class=\"headerlink\" title=\"InputModules\"></a><strong><code>InputModules</code></strong></h3><p>输入模块是配置和定制事件系统主逻辑的地方。 自带的输入模块有两个，一个是为独立输入(<code>StandaloneInputModule</code>)，另一个是为触摸输入(<code>TouchInputModule</code>)。 <code>StandaloneInputModule</code>是<code>PC</code>、<code>Mac&amp;Linux</code>上的具体实现，而<code>TouchInputModule</code>是<code>IOS</code>、<code>Android</code>等移动平台上的具体实现，每个模块都按照给定配置接收和分派事件。 运行<code>EventSystem</code>后，它会查看附加了哪些输入模块，并将事件传递给特定的模块。 内置的输入模块旨在支持常见的游戏配置，如触摸输入、控制器输入、键盘输入和鼠标输入等。</p>\n<p>它的主要任务有三个，分别是</p>\n<ul>\n<li><strong>处理输入</strong></li>\n<li><strong>管理事件状态</strong></li>\n<li><strong>发送事件到场景对象</strong></li>\n</ul>\n<p>在讲<code>Button</code>的时候我们提到鼠标的点击事件是在<code>BaseInputModule</code>中触发的，除此之外，<code>EventInterface</code>接口中的其他事件也都是由输入模块产生的，具体触发条件如下：</p>\n<ul>\n<li>当鼠标或触摸进入、退出当前对象时执行<code>pointerEnterHandler</code>、<code>pointerExitHandler</code>。</li>\n<li>在鼠标或者触摸按下、松开时执行<code>pointerDownHandler</code>、<code>pointerUpHandler</code>。</li>\n<li>在鼠标或触摸松开并且与按下时是同一个响应物体时执行<code>pointerClickHandler</code>。</li>\n<li>在鼠标或触摸位置发生偏移（偏移值大于一个很小的常量）时执行<code>beginDragHandler</code>。</li>\n<li>在鼠标或者触摸按下且当前对象可以响应拖拽事件时执行<code>initializePotentialDrag</code>。</li>\n<li>对象正在被拖拽且鼠标或触摸移动时执行<code>dragHandler</code>。</li>\n<li>对象正在被拖拽且鼠标或触摸松开时执行<code>endDragHandler</code>。</li>\n<li>鼠标或触摸松开且对象未响应<code>pointerClickHandler</code>情况下，如果对象正在被拖拽，执行<code>dropHandler</code>。</li>\n<li>当鼠标滚动差值大于零执行<code>scrollHandler</code>。</li>\n<li>当输入模块切换到<code>StandaloneInputModule</code>时执行<code>updateSelectedHandler</code>。（不需要Input类）</li>\n<li>当鼠标移动导致被选中的对象改变时，执行<code>selectHandler</code>和<code>deselectHandler</code>。</li>\n<li>导航事件可用情况下，按下上下左右键，执行<code>moveHandler</code>，按下确认键执行<code>submitHandler</code>，按下取消键执行<code>cancelHandler</code>。</li>\n</ul>\n<p>更加底层的调用还是<code>UnityEngine.Input</code>类，但可惜的是这部分<code>Unity</code>并没有开源。</p>\n<blockquote>\n<p>每次事件系统中只能有一个输入模块处于活跃状态，并且必须与<code>EventSystem</code>组件处于相同的游戏对象上。</p>\n</blockquote>\n<h3 id=\"执行事件\"><a href=\"#执行事件\" class=\"headerlink\" title=\"执行事件\"></a>执行事件</h3><p>既然<code>InputModule</code>主要就是处理设备输入，发送事件到场景对象，那这些事件是怎么执行的呢？在讲<code>Button</code>的时候，我们提到过<code>ExecuteEvent</code>类，其实事件的执行都是通过这个类进行的，不过也需要<code>EventInterface</code>接口配合。这个类中定义了许多接口，比如鼠标按下、点击、拖拽等，下图展示了部分接口的继承关系。</p>\n<p><img src=\"https://pic4.zhimg.com/80/v2-cfeebe5f05d3c8aa3dbe72fb99501913_720w.jpg\"></p>\n<p><code>ExecuteEvent</code>类中提供了一个方法让外部统一调用以执行事件</p>\n<figure class=\"highlight csharp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"built_in\">bool</span> <span class=\"title\">Execute</span>&lt;<span class=\"title\">T</span>&gt;(<span class=\"params\">GameObject target, BaseEventData eventData, EventFunction&lt;T&gt; functor</span>) <span class=\"keyword\">where</span> T : IEventSystemHandler</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"comment\">//从对象池中取出一个IEventSystemHandler类型的元素</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> internalHandlers = s_HandlerListPool.Get();</span><br><span class=\"line\">    <span class=\"comment\">//获取指定对象(target)的事件,并保存在internalHandlers中</span></span><br><span class=\"line\">    GetEventList&lt;T&gt;(target, internalHandlers);</span><br><span class=\"line\">    <span class=\"comment\">//  if (s_InternalHandlers.Count &gt; 0)</span></span><br><span class=\"line\">    <span class=\"comment\">//      Debug.Log(&quot;Executinng &quot; + typeof (T) + &quot; on &quot; + target);</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">var</span> internalHandlersCount = internalHandlers.Count;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &lt; internalHandlersCount; i++)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        T arg;</span><br><span class=\"line\">        <span class=\"keyword\">try</span></span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            arg = (T)internalHandlers[i];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">catch</span> (Exception e)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">var</span> temp = internalHandlers[i];</span><br><span class=\"line\">            Debug.LogException(<span class=\"keyword\">new</span> Exception(<span class=\"built_in\">string</span>.Format(<span class=\"string\">&quot;Type &#123;0&#125; expected &#123;1&#125; received.&quot;</span>, <span class=\"keyword\">typeof</span>(T).Name, temp.GetType().Name), e));</span><br><span class=\"line\">            <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">try</span></span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"comment\">//执行事件</span></span><br><span class=\"line\">            functor(arg, eventData);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">catch</span> (Exception e)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            Debug.LogException(e);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">var</span> handlerCount = internalHandlers.Count;</span><br><span class=\"line\">    s_HandlerListPool.Release(internalHandlers);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> handlerCount &gt; <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这个方法之前有讲过，主要就是查找<code>target</code>对象上的<code>T</code>类型的组件列表，并遍历执行。</p>\n<p>除此之外，还有一个<code>GetEventHandler</code>方法，它主要是通过冒泡的方式查找到能够处理指定事件的对象。</p>\n<figure class=\"highlight csharp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 在游戏对象上冒泡指定的事件，找出哪个对象将实际接收事件。 </span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> GameObject <span class=\"title\">GetEventHandler</span>&lt;<span class=\"title\">T</span>&gt;(<span class=\"params\">GameObject root</span>) <span class=\"keyword\">where</span> T : IEventSystemHandler</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (root == <span class=\"literal\">null</span>)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    Transform t = root.transform;</span><br><span class=\"line\">    <span class=\"comment\">//冒泡查找,如果物体本身不能处理输入的事件,交予parent处理</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (t != <span class=\"literal\">null</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (CanHandleEvent&lt;T&gt;(t.gameObject))</span><br><span class=\"line\">            <span class=\"keyword\">return</span> t.gameObject;</span><br><span class=\"line\">        t = t.parent;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"> <span class=\"comment\">// 指定的游戏对象是否能够处理指定的事件</span></span><br><span class=\"line\"> <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"built_in\">bool</span> <span class=\"title\">CanHandleEvent</span>&lt;<span class=\"title\">T</span>&gt;(<span class=\"params\">GameObject go</span>) <span class=\"keyword\">where</span> T : IEventSystemHandler</span></span><br><span class=\"line\"> &#123;</span><br><span class=\"line\">     <span class=\"keyword\">var</span> internalHandlers = s_HandlerListPool.Get();</span><br><span class=\"line\">     GetEventList&lt;T&gt;(go, internalHandlers);</span><br><span class=\"line\">     <span class=\"keyword\">var</span> handlerCount = internalHandlers.Count;</span><br><span class=\"line\">     s_HandlerListPool.Release(internalHandlers);</span><br><span class=\"line\">     <span class=\"keyword\">return</span> handlerCount != <span class=\"number\">0</span>;</span><br><span class=\"line\"> &#125;</span><br></pre></td></tr></table></figure>\n\n<p>比如我们在场景中创建一个<code>Button</code>，那这个<code>Button</code>还包含了Text组件，当鼠标点击的时候会调用<code>GetEventHandler</code>函数，该函数的<code>root</code>参数其实是<code>Text</code>，但是会通过冒泡的方式查找到它的父物体<code>Button</code>，然后调用<code>Button</code>的点击事件。</p>\n<h3 id=\"Raycasters\"><a href=\"#Raycasters\" class=\"headerlink\" title=\"Raycasters\"></a><strong><code>Raycasters</code></strong></h3><p>事件系统需要一个方法来检测当前输入事件需要发送到哪里，这是由<code>Raycasters</code>提供的。 给定一个屏幕空间位置，它们将收集所有潜在目标，找出它们是否在给定位置下，然后返回离屏幕最近的对象。 系统提供了以下几种类型的<code>Raycaster</code>:</p>\n<ul>\n<li><strong><code>Graphic Raycaster：</code> 检测<code>UI</code>元素</strong></li>\n<li><strong><code>Physics 2D Raycaster：</code> 用于<code>2D</code>物理元素</strong></li>\n<li><strong><code>Physics Raycaster：</code> 用于<code>3D</code>物理元素</strong></li>\n</ul>\n<p><img src=\"https://pic3.zhimg.com/80/v2-bd2f8a5e377ab90e25e1d70392f418ee_720w.jpg\"></p>\n<p><code>BaseRaycaster</code>是其他<code>Raycaster</code>的基类，这是是一个抽象类。在它<code>OnEnable</code>里将自己注册到<code>RaycasterManager</code>，并在<code>OnDisable</code>的时候从后者移除。</p>\n<p><code>RaycasterManager</code>是一个静态类，维护了一个<code>BaseRaycaster</code>类型的<code>List</code>，功能比较简单，包含获取(<code>Get</code>)、添加(<code>Add</code>)、移除(<code>Remove</code>)方法。</p>\n<p><code>BaseRaycaster</code>中最重要的就是<code>Raycast</code>方法了，它的子类都对该方法进行了重写。</p>\n<h3 id=\"Physics-Raycaster\"><a href=\"#Physics-Raycaster\" class=\"headerlink\" title=\"Physics Raycaster\"></a><code>Physics Raycaster</code></h3><p>它主要用于检测<code>3D</code>物理元素，并且保存被射线检测到物体的数据，下面是部分代码</p>\n<figure class=\"highlight csharp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">override</span> <span class=\"keyword\">void</span> <span class=\"title\">Raycast</span>(<span class=\"params\">PointerEventData eventData, List&lt;RaycastResult&gt; resultAppendList</span>)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"comment\">//判断是否超出摄像机的远近裁剪平面的距离</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!ComputeRayAndDistance(eventData, <span class=\"keyword\">ref</span> ray, <span class=\"keyword\">ref</span> displayIndex, <span class=\"keyword\">ref</span> distanceToClipPlane))</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//采用ReflectionMethodsCache.Singleton.raycast3DAll()来获取所有射线照射到的对象</span></span><br><span class=\"line\">    <span class=\"comment\">//用反射的方式把Physics.RaycastAll()方法缓存下来，让Unity的Physics模块与UI模块，保持低耦合，没有过分依赖。</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (m_MaxRayIntersections == <span class=\"number\">0</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        m_Hits = ReflectionMethodsCache.Singleton.raycast3DAll(ray, distanceToClipPlane, finalEventMask);</span><br><span class=\"line\">        hitCount = m_Hits.Length;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">else</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (m_LastMaxRayIntersections != m_MaxRayIntersections)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            m_Hits = <span class=\"keyword\">new</span> RaycastHit[m_MaxRayIntersections];</span><br><span class=\"line\">            m_LastMaxRayIntersections = m_MaxRayIntersections;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        hitCount = ReflectionMethodsCache.Singleton.getRaycastNonAlloc(ray, m_Hits, distanceToClipPlane, finalEventMask);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//获取到被射线照射到的对象，根据距离进行排序，然后包装成RaycastResult,加入到resultAppendList中</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (hitCount != <span class=\"number\">0</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (hitCount &gt; <span class=\"number\">1</span>)</span><br><span class=\"line\">            System.Array.Sort(m_Hits, <span class=\"number\">0</span>, hitCount, RaycastHitComparer.instance);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"built_in\">int</span> b = <span class=\"number\">0</span>, bmax = hitCount; b &lt; bmax; ++b)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">var</span> result = <span class=\"keyword\">new</span> RaycastResult</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                ...<span class=\"comment\">//为result赋值</span></span><br><span class=\"line\">            &#125;;</span><br><span class=\"line\">            resultAppendList.Add(result);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><code>Physics2DRaycaster</code>继承自<code>PhysicsRaycaster</code>，实现功能和方式基本一致，只不过是用于检测<code>2D</code>物体，这里不具体讲解</p>\n<h3 id=\"GraphicRaycast\"><a href=\"#GraphicRaycast\" class=\"headerlink\" title=\"GraphicRaycast\"></a><code>GraphicRaycast</code></h3><p><strong><code>GraphicRaycast</code>用于检测<code>UI</code>元素，它依赖于<code>Canvas</code>，我们在场景中添加<code>Canvas</code>默认都会包含一个<code>GraphicRaycast</code>组件。它先获取鼠标坐标，将其转换为<code>Camera</code>的视角坐标，然后分情况计算射线的距离（<code>hitDistance</code>），调用<code>Graphic</code>的<code>Raycast</code>方法来获取鼠标点下方的元素，最后将满足条件的结果添加到<code>resultAppendList</code>中。</strong></p>\n<p><img src=\"https://pic4.zhimg.com/80/v2-8bd60abc5511daada3c336a9aee12193_720w.jpg\"></p>\n<p>一大波代码来袭，不感兴趣可以跳过</p>\n<figure class=\"highlight csharp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br><span class=\"line\">147</span><br><span class=\"line\">148</span><br><span class=\"line\">149</span><br><span class=\"line\">150</span><br><span class=\"line\">151</span><br><span class=\"line\">152</span><br><span class=\"line\">153</span><br><span class=\"line\">154</span><br><span class=\"line\">155</span><br><span class=\"line\">156</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">override</span> <span class=\"keyword\">void</span> <span class=\"title\">Raycast</span>(<span class=\"params\">PointerEventData eventData, List&lt;RaycastResult&gt; resultAppendList</span>)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (canvas == <span class=\"literal\">null</span>)</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//返回Canvas上的所有包含Graphic脚本并且raycastTarget=true的游戏物体</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> canvasGraphics = GraphicRegistry.GetRaycastableGraphicsForCanvas(canvas);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (canvasGraphics == <span class=\"literal\">null</span> || canvasGraphics.Count == <span class=\"number\">0</span>)</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">int</span> displayIndex;</span><br><span class=\"line\">    <span class=\"comment\">//画布在ScreenSpaceOverlay模式下默认为null</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> currentEventCamera = eventCamera; <span class=\"comment\">// Property can call Camera.main, so cache the reference</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (canvas.renderMode == RenderMode.ScreenSpaceOverlay || currentEventCamera == <span class=\"literal\">null</span>)</span><br><span class=\"line\">        displayIndex = canvas.targetDisplay;</span><br><span class=\"line\">    <span class=\"keyword\">else</span></span><br><span class=\"line\">        displayIndex = currentEventCamera.targetDisplay;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//获取鼠标位置</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> eventPosition = Display.RelativeMouseAt(eventData.position);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (eventPosition != Vector3.zero)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"built_in\">int</span> eventDisplayIndex = (<span class=\"built_in\">int</span>)eventPosition.z;</span><br><span class=\"line\">      </span><br><span class=\"line\">        <span class=\"keyword\">if</span> (eventDisplayIndex != displayIndex)</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">else</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        eventPosition = eventData.position;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Convert to view space</span></span><br><span class=\"line\">    <span class=\"comment\">//将鼠标点在屏幕上的坐标转换成摄像机的视角坐标,如果超出范围则return</span></span><br><span class=\"line\">    Vector2 pos;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (currentEventCamera == <span class=\"literal\">null</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"built_in\">float</span> w = Screen.width;</span><br><span class=\"line\">        <span class=\"built_in\">float</span> h = Screen.height;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (displayIndex &gt; <span class=\"number\">0</span> &amp;&amp; displayIndex &lt; Display.displays.Length)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            w = Display.displays[displayIndex].systemWidth;</span><br><span class=\"line\">            h = Display.displays[displayIndex].systemHeight;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        pos = <span class=\"keyword\">new</span> Vector2(eventPosition.x / w, eventPosition.y / h);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">else</span></span><br><span class=\"line\">        pos = currentEventCamera.ScreenToViewportPoint(eventPosition);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// If it&#x27;s outside the camera&#x27;s viewport, do nothing</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (pos.x &lt; <span class=\"number\">0f</span> || pos.x &gt; <span class=\"number\">1f</span> || pos.y &lt; <span class=\"number\">0f</span> || pos.y &gt; <span class=\"number\">1f</span>)</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">float</span> hitDistance = <span class=\"built_in\">float</span>.MaxValue;</span><br><span class=\"line\"></span><br><span class=\"line\">    Ray ray = <span class=\"keyword\">new</span> Ray();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//如果currentEventCamera不为空,摄像机发射射线</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (currentEventCamera != <span class=\"literal\">null</span>)</span><br><span class=\"line\">        ray = currentEventCamera.ScreenPointToRay(eventPosition);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//如果当前画布不是ScreenSpaceOverlay模式并且blockingObjects != BlockingObjects.None</span></span><br><span class=\"line\">    <span class=\"comment\">//计算hitDistance的值</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (canvas.renderMode != RenderMode.ScreenSpaceOverlay &amp;&amp; blockingObjects != BlockingObjects.None)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"built_in\">float</span> distanceToClipPlane = <span class=\"number\">100.0f</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (currentEventCamera != <span class=\"literal\">null</span>)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"built_in\">float</span> projectionDirection = ray.direction.z;</span><br><span class=\"line\">            distanceToClipPlane = Mathf.Approximately(<span class=\"number\">0.0f</span>, projectionDirection)</span><br><span class=\"line\">                ? Mathf.Infinity</span><br><span class=\"line\">                : Mathf.Abs((currentEventCamera.farClipPlane - currentEventCamera.nearClipPlane) / projectionDirection);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"meta\">#<span class=\"keyword\">if</span> PACKAGE_PHYSICS</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (blockingObjects == BlockingObjects.ThreeD || blockingObjects == BlockingObjects.All)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (ReflectionMethodsCache.Singleton.raycast3D != <span class=\"literal\">null</span>)</span><br><span class=\"line\">                &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">var</span> hits = ReflectionMethodsCache.Singleton.raycast3DAll(ray, distanceToClipPlane, (<span class=\"built_in\">int</span>)m_BlockingMask);</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (hits.Length &gt; <span class=\"number\">0</span>)</span><br><span class=\"line\">                        hitDistance = hits[<span class=\"number\">0</span>].distance;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        <span class=\"meta\">#<span class=\"keyword\">endif</span></span></span><br><span class=\"line\">            <span class=\"meta\">#<span class=\"keyword\">if</span> PACKAGE_PHYSICS2D</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (blockingObjects == BlockingObjects.TwoD || blockingObjects == BlockingObjects.All)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (ReflectionMethodsCache.Singleton.raycast2D != <span class=\"literal\">null</span>)</span><br><span class=\"line\">                &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">var</span> hits = ReflectionMethodsCache.Singleton.getRayIntersectionAll(ray, distanceToClipPlane, (<span class=\"built_in\">int</span>)m_BlockingMask);</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (hits.Length &gt; <span class=\"number\">0</span>)</span><br><span class=\"line\">                        hitDistance = hits[<span class=\"number\">0</span>].distance;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        <span class=\"meta\">#<span class=\"keyword\">endif</span></span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    m_RaycastResults.Clear();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//调用Raycast函数重载</span></span><br><span class=\"line\">    Raycast(canvas, currentEventCamera, eventPosition, canvasGraphics, m_RaycastResults);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//遍历m_RaycastResults，判断Graphic的方向向量和Camera的方向向量是否相交，然后判断Graphic是否在Camera的前面，并且距离小于等于hitDistance，满足了这些条件，才会把它打包成RaycastResult添加到resultAppendList里。</span></span><br><span class=\"line\">    <span class=\"built_in\">int</span> totalCount = m_RaycastResults.Count;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> index = <span class=\"number\">0</span>; index &lt; totalCount; index++)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> go = m_RaycastResults[index].gameObject;</span><br><span class=\"line\">        <span class=\"built_in\">bool</span> appendGraphic = <span class=\"literal\">true</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (ignoreReversedGraphics)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (currentEventCamera == <span class=\"literal\">null</span>)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                <span class=\"comment\">// If we dont have a camera we know that we should always be facing forward</span></span><br><span class=\"line\">                <span class=\"keyword\">var</span> dir = go.transform.rotation * Vector3.forward;</span><br><span class=\"line\">                appendGraphic = Vector3.Dot(Vector3.forward, dir) &gt; <span class=\"number\">0</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">else</span></span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                <span class=\"comment\">// If we have a camera compare the direction against the cameras forward.</span></span><br><span class=\"line\">                <span class=\"keyword\">var</span> cameraForward = currentEventCamera.transform.rotation * Vector3.forward * currentEventCamera.nearClipPlane;</span><br><span class=\"line\">                appendGraphic = Vector3.Dot(go.transform.position - currentEventCamera.transform.position - cameraForward, go.transform.forward) &gt;= <span class=\"number\">0</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (appendGraphic)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"built_in\">float</span> distance = <span class=\"number\">0</span>;</span><br><span class=\"line\">            Transform trans = go.transform;</span><br><span class=\"line\">            Vector3 transForward = trans.forward;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (currentEventCamera == <span class=\"literal\">null</span> || canvas.renderMode == RenderMode.ScreenSpaceOverlay)</span><br><span class=\"line\">                distance = <span class=\"number\">0</span>;</span><br><span class=\"line\">            <span class=\"keyword\">else</span></span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                <span class=\"comment\">// http://geomalgorithms.com/a06-_intersect-2.html</span></span><br><span class=\"line\">                distance = (Vector3.Dot(transForward, trans.position - ray.origin) / Vector3.Dot(transForward, ray.direction));</span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"comment\">// Check to see if the go is behind the camera.</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (distance &lt; <span class=\"number\">0</span>)</span><br><span class=\"line\">                    <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (distance &gt;= hitDistance)</span><br><span class=\"line\">                <span class=\"keyword\">continue</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">var</span> castResult = <span class=\"keyword\">new</span> RaycastResult</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                ......</span><br><span class=\"line\">            &#125;;</span><br><span class=\"line\">            resultAppendList.Add(castResult);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n\n<p>上述代码中调用了<code>Raycast</code>函数重载，作用是向屏幕投射射线并收集屏幕下方所有挂载了<code>Graphic</code>脚本的游戏对象，该函数内容为：</p>\n<figure class=\"highlight csharp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">Raycast</span>(<span class=\"params\">Canvas canvas, Camera eventCamera, Vector2 pointerPosition, IList&lt;Graphic&gt; foundGraphics, List&lt;Graphic&gt; results</span>)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"comment\">// Necessary for the event system</span></span><br><span class=\"line\">    <span class=\"comment\">//遍历场景内Graphic对象(挂载Graphic脚本的对象)</span></span><br><span class=\"line\">    <span class=\"built_in\">int</span> totalCount = foundGraphics.Count;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"built_in\">int</span> i = <span class=\"number\">0</span>; i &lt; totalCount; ++i)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        Graphic graphic = foundGraphics[i];</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// -1 means it hasn&#x27;t been processed by the canvas, which means it isn&#x27;t actually drawn</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!graphic.raycastTarget || graphic.canvasRenderer.cull || graphic.depth == <span class=\"number\">-1</span>)</span><br><span class=\"line\">            <span class=\"keyword\">continue</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//目标点是否在矩阵中</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!RectTransformUtility.RectangleContainsScreenPoint(graphic.rectTransform, pointerPosition, eventCamera, graphic.raycastPadding))</span><br><span class=\"line\">            <span class=\"keyword\">continue</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//超出摄像机范围</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (eventCamera != <span class=\"literal\">null</span> &amp;&amp; eventCamera.WorldToScreenPoint(graphic.rectTransform.position).z &gt; eventCamera.farClipPlane)</span><br><span class=\"line\">            <span class=\"keyword\">continue</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//调用符合条件的Graphic的Raycast方法</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (graphic.Raycast(pointerPosition, eventCamera))</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            s_SortedGraphics.Add(graphic);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    s_SortedGraphics.Sort((g1, g2) =&gt; g2.depth.CompareTo(g1.depth));</span><br><span class=\"line\">    totalCount = s_SortedGraphics.Count;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"built_in\">int</span> i = <span class=\"number\">0</span>; i &lt; totalCount; ++i)</span><br><span class=\"line\">        results.Add(s_SortedGraphics[i]);</span><br><span class=\"line\"></span><br><span class=\"line\">    s_SortedGraphics.Clear();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p> <strong>函数中又调用了<code>Graphic</code>类的<code>Raycast</code>函数，它主要是做两件事，一件是使用<code>RectTransform</code>的值过滤元素，另一件是使用<code>Raycast</code>函数确定射线击中的元素。</strong> <code>RawImage</code>、<code>Image</code>和<code>Text</code>都间接继承自<code>Graphic</code>。</p>\n<p><img src=\"https://pic2.zhimg.com/80/v2-b9be049e2a433d8a8437328d49e8dc4d_720w.jpg\"></p>\n<figure class=\"highlight csharp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">virtual</span> <span class=\"built_in\">bool</span> <span class=\"title\">Raycast</span>(<span class=\"params\">Vector2 sp, Camera eventCamera</span>)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!isActiveAndEnabled)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//UI元素,比如Image,Button等</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> t = transform;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">var</span> components = ListPool&lt;Component&gt;.Get();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">bool</span> ignoreParentGroups = <span class=\"literal\">false</span>;</span><br><span class=\"line\">    <span class=\"built_in\">bool</span> continueTraversal = <span class=\"literal\">true</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (t != <span class=\"literal\">null</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        t.GetComponents(components);</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &lt; components.Count; i++)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">            Debug.Log(components[i].name);</span><br><span class=\"line\">            <span class=\"keyword\">var</span> canvas = components[i] <span class=\"keyword\">as</span> Canvas;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (canvas != <span class=\"literal\">null</span> &amp;&amp; canvas.overrideSorting)</span><br><span class=\"line\">                continueTraversal = <span class=\"literal\">false</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">//获取ICanvasRaycastFilter组件(Image,Mask,RectMask2D)</span></span><br><span class=\"line\">            <span class=\"keyword\">var</span> filter = components[i] <span class=\"keyword\">as</span> ICanvasRaycastFilter;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (filter == <span class=\"literal\">null</span>)</span><br><span class=\"line\">                <span class=\"keyword\">continue</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">var</span> raycastValid = <span class=\"literal\">true</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">//判断sp点是否在有效的范围内</span></span><br><span class=\"line\">            <span class=\"keyword\">var</span> <span class=\"keyword\">group</span> = components[i] <span class=\"keyword\">as</span> CanvasGroup;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (<span class=\"keyword\">group</span> != <span class=\"literal\">null</span>)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (ignoreParentGroups == <span class=\"literal\">false</span> &amp;&amp; <span class=\"keyword\">group</span>.ignoreParentGroups)</span><br><span class=\"line\">                &#123;</span><br><span class=\"line\">                    ignoreParentGroups = <span class=\"literal\">true</span>;</span><br><span class=\"line\">                    raycastValid = filter.IsRaycastLocationValid(sp, eventCamera);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (!ignoreParentGroups)</span><br><span class=\"line\">                    raycastValid = filter.IsRaycastLocationValid(sp, eventCamera);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">else</span></span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                raycastValid = filter.IsRaycastLocationValid(sp, eventCamera);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (!raycastValid)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                ListPool&lt;Component&gt;.Release(components);</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">//遍历它的父物体</span></span><br><span class=\"line\">        t = continueTraversal ? t.parent : <span class=\"literal\">null</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    ListPool&lt;Component&gt;.Release(components);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这里也使用了<code>ICanvasRaycastFilter</code>接口中的<code>IsRaycastLocationValid</code>函数，主要还是判断点的位置是否有效，不过这里使用了Alpha测试。Image、Mask以及RectMask2D都继承了该接口。</p>\n<p><img src=\"https://pic4.zhimg.com/80/v2-d80ee9c4b4f5c61ef1c05a1fc793bfab_720w.jpg\"></p>\n<figure class=\"highlight csharp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">virtual</span> <span class=\"built_in\">bool</span> <span class=\"title\">IsRaycastLocationValid</span>(<span class=\"params\">Vector2 screenPoint, Camera eventCamera</span>)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"comment\">//小于阈值(alphaHitTestMinimumThreshold)的Alpha值将导致射线事件穿透图像。 </span></span><br><span class=\"line\">    <span class=\"comment\">//值为1将导致只有完全不透明的像素在图像上注册相应射线事件。</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (alphaHitTestMinimumThreshold &lt;= <span class=\"number\">0</span>)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (alphaHitTestMinimumThreshold &gt; <span class=\"number\">1</span>)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (activeSprite == <span class=\"literal\">null</span>)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    Vector2 local;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!RectTransformUtility.ScreenPointToLocalPointInRectangle(rectTransform, screenPoint, eventCamera, <span class=\"keyword\">out</span> local))</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    Rect rect = GetPixelAdjustedRect();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Convert to have lower left corner as reference point.</span></span><br><span class=\"line\">    local.x += rectTransform.pivot.x * rect.width;</span><br><span class=\"line\">    local.y += rectTransform.pivot.y * rect.height;</span><br><span class=\"line\"></span><br><span class=\"line\">    local = MapCoordinate(local, rect);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Convert local coordinates to texture space.</span></span><br><span class=\"line\">    Rect spriteRect = activeSprite.textureRect;</span><br><span class=\"line\">    <span class=\"built_in\">float</span> x = (spriteRect.x + local.x) / activeSprite.texture.width;</span><br><span class=\"line\">    <span class=\"built_in\">float</span> y = (spriteRect.y + local.y) / activeSprite.texture.height;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">try</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> activeSprite.texture.GetPixelBilinear(x, y).a &gt;= alphaHitTestMinimumThreshold;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">catch</span> (UnityException e)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        Debug.LogError(<span class=\"string\">&quot;Using alphaHitTestMinimumThreshold greater than 0 on Image whose sprite texture cannot be read. &quot;</span> + e.Message + <span class=\"string\">&quot; Also make sure to disable sprite packing for this sprite.&quot;</span>, <span class=\"keyword\">this</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"EventData\"><a href=\"#EventData\" class=\"headerlink\" title=\"EventData\"></a><code>EventData</code></h3><p><code>EventData</code>用以存储事件信息，涉及到的东西不多，不展开讲解，层级关系如下图所示</p>\n<p><img src=\"https://pic1.zhimg.com/80/v2-a72d1e210d9964fe63a440b4172d84ac_720w.jpg\"></p>\n<h2 id=\"实战：为Button的点击事件添加参数\"><a href=\"#实战：为Button的点击事件添加参数\" class=\"headerlink\" title=\"实战：为Button的点击事件添加参数\"></a><strong>实战：为Button的点击事件添加参数</strong></h2><p>在执行<code>Button</code>点击事件时，有些情况下我们需要获取触发事件的<code>Button</code>对象信息，这时可以自己实现一个<code>Button</code>点击事件</p>\n<figure class=\"highlight csharp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"><span class=\"doctag\">///</span> <span class=\"doctag\">&lt;summary&gt;</span></span></span><br><span class=\"line\"><span class=\"comment\"><span class=\"doctag\">///</span> UI事件监听器(与Button等UI挂在同一个物体上）：管理所有UGUI事件，提供事件参数类</span></span><br><span class=\"line\"><span class=\"comment\"><span class=\"doctag\">///</span> 若想看所有相关委托  自行查看EventTrigger类</span></span><br><span class=\"line\"><span class=\"comment\"><span class=\"doctag\">///</span> <span class=\"doctag\">&lt;/summary&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title\">UIEventListener</span> : <span class=\"title\">MonoBehaviour</span>, <span class=\"title\">IPointerClickHandler</span>, <span class=\"title\">IPointerDownHandler</span>, <span class=\"title\">IPointerUpHandler</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"comment\">//2.定义委托</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"built_in\">delegate</span> <span class=\"keyword\">void</span> <span class=\"title\">PointerEventHandler</span>(<span class=\"params\">PointerEventData eventData</span>)</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//3.声明事件</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">event</span> PointerEventHandler PointerClick;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">event</span> PointerEventHandler PointerDown;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">event</span> PointerEventHandler PointerUp;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\"><span class=\"doctag\">///</span> <span class=\"doctag\">&lt;summary&gt;</span></span></span><br><span class=\"line\">    <span class=\"comment\"><span class=\"doctag\">///</span> 通过变换组件获取事件监听器</span></span><br><span class=\"line\">    <span class=\"comment\"><span class=\"doctag\">///</span> <span class=\"doctag\">&lt;/summary&gt;</span></span></span><br><span class=\"line\">    <span class=\"comment\"><span class=\"doctag\">///</span> <span class=\"doctag\">&lt;param name=&quot;transform&quot;&gt;</span><span class=\"doctag\">&lt;/param&gt;</span></span></span><br><span class=\"line\">    <span class=\"comment\"><span class=\"doctag\">///</span> <span class=\"doctag\">&lt;returns&gt;</span><span class=\"doctag\">&lt;/returns&gt;</span></span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> UIEventListener <span class=\"title\">GetEventListener</span>(<span class=\"params\">Transform transform</span>)</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        UIEventListener uIEventListener = transform.GetComponent&lt;UIEventListener&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (uIEventListener == <span class=\"literal\">null</span>)</span><br><span class=\"line\">            uIEventListener = transform.gameObject.AddComponent&lt;UIEventListener&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> uIEventListener;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//1.实现接口</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">OnPointerClick</span>(<span class=\"params\">PointerEventData eventData</span>)</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"comment\">//表示抽象的有  抽象类  接口（多类抽象行为）  委托（一类抽象行为）</span></span><br><span class=\"line\">        <span class=\"comment\">//4.引发事件</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (PointerClick != <span class=\"literal\">null</span>)</span><br><span class=\"line\">            PointerClick(eventData);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">OnPointerDown</span>(<span class=\"params\">PointerEventData eventData</span>)</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        PointerDown?.Invoke(eventData);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">OnPointerUp</span>(<span class=\"params\">PointerEventData eventData</span>)</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        PointerUp?.Invoke(eventData);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>使用的时候，我们只需要将它挂载到<code>Button</code>组件上，然后在<code>PointerClick</code>事件中添加自己的处理函数。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a><strong>总结</strong></h2><p><code>Button</code>点击事件怎么触发的呢？首先是<code>EventSystem</code>在<code>Update</code>中调用当前输入模块的<code>Process</code>方法处理所有的鼠标事件，并且输入模块会调用<code>RaycastAll</code>来得到目标信息，通过冒泡的方式找到事件实际接收者并执行点击事件(这只是总体流程，中间省略很多具体步骤)。</p>\n<p><img src=\"https://pic2.zhimg.com/80/v2-46b1ca8927625fb9ffb2cf94092b4651_720w.jpg\"></p>\n<p>最后来一张层级关系图</p>\n<p><img src=\"https://pic2.zhimg.com/80/v2-9a23d2a2f220e3e8100607ddc0999721_720w.jpg\"></p>\n"},{"title":"Hello World","_content":"Welcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/one-command-deployment.html)\n","source":"_posts/hello-world.md","raw":"---\ntitle: Hello World   \ntags: \n  - [article]\ncategories: \n  - [article]\n---\nWelcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/one-command-deployment.html)\n","slug":"hello-world","published":1,"date":"2022-03-15T12:51:45.607Z","updated":"2022-03-15T14:46:20.582Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl0saopkh0002d0vh7dwy9y4q","content":"<p>Welcome to <a href=\"https://hexo.io/\">Hexo</a>! This is your very first post. Check <a href=\"https://hexo.io/docs/\">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href=\"https://hexo.io/docs/troubleshooting.html\">troubleshooting</a> or you can ask me on <a href=\"https://github.com/hexojs/hexo/issues\">GitHub</a>.</p>\n<h2 id=\"Quick-Start\"><a href=\"#Quick-Start\" class=\"headerlink\" title=\"Quick Start\"></a>Quick Start</h2><h3 id=\"Create-a-new-post\"><a href=\"#Create-a-new-post\" class=\"headerlink\" title=\"Create a new post\"></a>Create a new post</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo new <span class=\"string\">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/writing.html\">Writing</a></p>\n<h3 id=\"Run-server\"><a href=\"#Run-server\" class=\"headerlink\" title=\"Run server\"></a>Run server</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo server</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/server.html\">Server</a></p>\n<h3 id=\"Generate-static-files\"><a href=\"#Generate-static-files\" class=\"headerlink\" title=\"Generate static files\"></a>Generate static files</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo generate</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/generating.html\">Generating</a></p>\n<h3 id=\"Deploy-to-remote-sites\"><a href=\"#Deploy-to-remote-sites\" class=\"headerlink\" title=\"Deploy to remote sites\"></a>Deploy to remote sites</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo deploy</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/one-command-deployment.html\">Deployment</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p>Welcome to <a href=\"https://hexo.io/\">Hexo</a>! This is your very first post. Check <a href=\"https://hexo.io/docs/\">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href=\"https://hexo.io/docs/troubleshooting.html\">troubleshooting</a> or you can ask me on <a href=\"https://github.com/hexojs/hexo/issues\">GitHub</a>.</p>\n<h2 id=\"Quick-Start\"><a href=\"#Quick-Start\" class=\"headerlink\" title=\"Quick Start\"></a>Quick Start</h2><h3 id=\"Create-a-new-post\"><a href=\"#Create-a-new-post\" class=\"headerlink\" title=\"Create a new post\"></a>Create a new post</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo new <span class=\"string\">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/writing.html\">Writing</a></p>\n<h3 id=\"Run-server\"><a href=\"#Run-server\" class=\"headerlink\" title=\"Run server\"></a>Run server</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo server</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/server.html\">Server</a></p>\n<h3 id=\"Generate-static-files\"><a href=\"#Generate-static-files\" class=\"headerlink\" title=\"Generate static files\"></a>Generate static files</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo generate</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/generating.html\">Generating</a></p>\n<h3 id=\"Deploy-to-remote-sites\"><a href=\"#Deploy-to-remote-sites\" class=\"headerlink\" title=\"Deploy to remote sites\"></a>Deploy to remote sites</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo deploy</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/one-command-deployment.html\">Deployment</a></p>\n"},{"title":"一次测试","date":"2022-03-15T13:00:02.000Z","_content":"\n这里是正文\n---\n正文","source":"_posts/test.md","raw":"---\ntitle: 一次测试\ndate: 2022-03-15 21:00:02\ntags: \n  - [program]\ncategories: \n  - [program]\n---\n\n这里是正文\n---\n正文","slug":"test","published":1,"updated":"2022-03-15T14:45:41.689Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl0saopkx0004d0vh8pht6plw","content":"<h2 id=\"这里是正文\"><a href=\"#这里是正文\" class=\"headerlink\" title=\"这里是正文\"></a>这里是正文</h2><p>正文</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"这里是正文\"><a href=\"#这里是正文\" class=\"headerlink\" title=\"这里是正文\"></a>这里是正文</h2><p>正文</p>\n"}],"PostAsset":[],"PostCategory":[{"post_id":"cl0saopkd0001d0vhbodb1blz","category_id":"cl0saopl10005d0vh7fjcftih","_id":"cl0saoplc000bd0vh5f3tddwc"},{"post_id":"cl0saopkh0002d0vh7dwy9y4q","category_id":"cl0saopl90007d0vh6l5a9xzi","_id":"cl0saopld000ed0vhgb8og2bs"},{"post_id":"cl0saopkx0004d0vh8pht6plw","category_id":"cl0saopl10005d0vh7fjcftih","_id":"cl0saople000fd0vh4jihdw3m"}],"PostTag":[{"post_id":"cl0saopkd0001d0vhbodb1blz","tag_id":"cl0saopkl0003d0vh4qcp2zp7","_id":"cl0saopl90008d0vhgv5yaxkf"},{"post_id":"cl0saopkh0002d0vh7dwy9y4q","tag_id":"cl0saopl80006d0vheyfzevt7","_id":"cl0saoplc000cd0vh2ie4g8e3"},{"post_id":"cl0saopkx0004d0vh8pht6plw","tag_id":"cl0saopkl0003d0vh4qcp2zp7","_id":"cl0saopld000dd0vhcbzgfxah"}],"Tag":[{"name":"program","_id":"cl0saopkl0003d0vh4qcp2zp7"},{"name":"article","_id":"cl0saopl80006d0vheyfzevt7"}]}}